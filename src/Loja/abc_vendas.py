# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException,NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.chrome.service import Service 
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime, timedelta, date
import pandas as pd
import glob
import os
import numpy as np
from urllib.parse import quote
from sqlalchemy import create_engine, text
from sqlalchemy.types import String
from sqlalchemy.types import Integer
from sqlalchemy.types import Float
from sqlalchemy.types import DateTime
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException
import chromedriver_autoinstaller
from dotenv import load_dotenv
import logging
import io
from pandas.api.types import is_scalar
import psycopg2.extras
from seleniumbase import Driver
from psycopg2.extras import execute_values
from selenium.webdriver import ActionChains
from selenium.webdriver.common.keys import Keys
import time

# Configuração do sistema de logging

def setup_logger():
    # Cria pasta de logs se não existir
    log_dir = "logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Define formato da data para o nome do arquivo de log
    data_hora_atual = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = f"{log_dir}/execucao_{data_hora_atual}.log"
    
    # Configuração do logger
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger()

# Inicialização do logger global
logger = setup_logger()

# Carregando variáveis de ambiente do arquivo .env
load_dotenv()

ciclos_2024 = [
    {"ciclo":  1, "inicio": "26/12/2023", "fim": "21/01/2024"},
    {"ciclo":  2, "inicio": "22/01/2024", "fim": "11/02/2024"},
    {"ciclo":  3, "inicio": "12/02/2024", "fim": "03/03/2024"},
    {"ciclo":  4, "inicio": "04/03/2024", "fim": "24/03/2024"},
    {"ciclo":  5, "inicio": "25/03/2024", "fim": "14/04/2024"},
    {"ciclo":  6, "inicio": "15/04/2024", "fim": "12/05/2024"},
    {"ciclo":  7, "inicio": "13/05/2024", "fim": "26/05/2024"},
    {"ciclo":  8, "inicio": "27/05/2024", "fim": "12/06/2024"},
    {"ciclo":  9, "inicio": "13/06/2024", "fim": "30/06/2024"},
    {"ciclo": 10, "inicio": "01/07/2024", "fim": "22/07/2024"},
    {"ciclo": 11, "inicio": "23/07/2024", "fim": "11/08/2024"},
    {"ciclo": 12, "inicio": "12/08/2024", "fim": "01/09/2024"},
    {"ciclo": 13, "inicio": "02/09/2024", "fim": "21/09/2024"},
    {"ciclo": 14, "inicio": "22/09/2024", "fim": "13/10/2024"},
    {"ciclo": 15, "inicio": "14/10/2024", "fim": "03/11/2024"},
    {"ciclo": 16, "inicio": "04/11/2024", "fim": "01/12/2024"},
    {"ciclo": 17, "inicio": "02/12/2024", "fim": "25/12/2024"}, 
]

class TratarDados():
    def __init__(self):
        # Caminhos portáveis: primeiro busca na pasta 'downloads' do projeto, depois em 'Downloads' do usuário
        base_dir = os.path.dirname(os.path.abspath(__file__))
        projeto_downloads = os.path.join(base_dir, 'downloads')
        usuario_downloads = os.path.join(os.path.expanduser('~'), 'Downloads')

        padroes = [
            os.path.join(projeto_downloads, '*.csv'),
            os.path.join(usuario_downloads, '*.csv'),
        ]

        list_of_files = []
        for padrao in padroes:
            arquivos = glob.glob(padrao)
            if arquivos:
                list_of_files.extend(arquivos)

        if not list_of_files:
            raise FileNotFoundError("Nenhum arquivo CSV encontrado nas pastas padrão ('downloads' do projeto ou 'Downloads' do usuário).")

        self.file = max(list_of_files, key=os.path.getctime)
        self.file = r"C:\Users\Grupo Garbo\Downloads\relatorioABCVenda (2).csv"
        

    def processar_arquivo_abc_vendas(self):
        try:
            logger.info(f"Iniciando processamento do arquivo: {self.file}")
            
            df = pd.read_csv(self.file,
                             sep=';',
                             encoding='ISO-8859-1',
                             on_bad_lines='skip',
                             engine='python')
            
            logger.info(f"Arquivo lido com sucesso. Total de linhas: {len(df)}")

            # Mapeamento de colunas para os novos dados
            mapeamento_colunas = {
                'Quebra': 'data',
                'Quebra2': 'Cod_vendedor',
                'Código': 'Cod_produto',
                'Descrição': 'Produto',
                'Quantidade': 'Qtd_itens',
                'Faturamento': 'Faturamento',
                'Preço médio': 'Preço_medio',
                'Custo Total': 'Custo_total',
                'Imposto Estadual': 'Imposto_estadual',
                'Imposto Federal': 'Imposto_federal',
                'Lucro': 'Lucro',
                'Margem': 'Margem',
                'Markup': 'Markup',
                'Participação': 'Participacao',
                'Acumulado': 'Acumulado',
                'ICMS ST': 'ICMS_ST',
                'Fecop ST': 'Fecop_ST'
            }

            # Renomear colunas existentes
            colunas_existentes = {k: v for k, v in mapeamento_colunas.items() if k in df.columns}
            logger.info(f"Colunas renomeadas: {list(colunas_existentes.values())}")
            df = df.rename(columns=colunas_existentes)
            
            
            df[["id_consultor", "nome_consultor"]] = df["Cod_vendedor"].str.split(" - ", n=1, expand=True)
            df = df.drop(columns=["Cod_vendedor"])
            
            
            # Converter colunas numéricas
            cols_numericas = [
                "Qtd_itens", "Faturamento", "Preço_medio", "Custo_total",
                "Imposto_estadual", "Imposto_federal", "Lucro", "Margem",
                "Markup", "Participacao", "Acumulado", "ICMS_ST", "Fecop_ST"
            ]

            for col in cols_numericas:
                if col in df.columns:
                    # trocar vírgula por ponto antes de converter
                    df[col] = pd.to_numeric(df[col].astype(str).str.replace('.', '', regex=False).str.replace(',', '.'), errors="coerce")

            df["id_consultor"] = pd.to_numeric(df["id_consultor"], errors="coerce").astype("Int64")

            # Substituir valores NaN por None
            df = df.where(pd.notna(df), None)
            

            logger.info("Processamento concluído com sucesso")
            return df

        except Exception as e:
            logger.error(f"Erro ao processar arquivo: {str(e)}")
            raise

class Banco():
    def __init__(self):
        self.engine = create_engine(os.getenv('DATABASE_URL')) 
        try:
            conn = self.engine.connect()
            result = conn.execute(text("SELECT 1"))
            if result.scalar() == 1:
                print("Conectado ao banco com sucesso!")
                self.criar_tabela()
            else:
                print("Erro ao conectar ao banco")
            conn.close()
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise
        
    def criar_tabela(self):
        try:
            with self.engine.connect() as conn:
                conn.execute(text("""
                    CREATE TABLE IF NOT EXISTS itens_pedidos (
                        CodigoPedido varchar(30) ,
                        CodigoProduto varchar(30) ,
                        Produto VARCHAR(200),
                        DataCaptacao DATE,
                        CicloCaptacao VARCHAR(10),
                        DataFaturamento DATE,
                        CicloFaturamento VARCHAR(10),
                        Pessoa VARCHAR(30),
                        NomePessoa VARCHAR(255),
                        Papel VARCHAR(20),
                        SituacaoFiscal VARCHAR(40),
                        NotaFiscal VARCHAR(30),
                        MeioCaptacao VARCHAR(30),
                        CodPlanoPagamento VARCHAR(30),
                        PlanoPagamento VARCHAR(255),
                        TipoEntrega VARCHAR(30),
                        CodUsuarioCriacao VARCHAR(30),
                        UsuarioCriacao VARCHAR(255),
                        CodUsuarioFinalizacao VARCHAR(30),
                        UsuarioFinalizacao VARCHAR(255),
                        CodCD VARCHAR(30),
                        CanalDistribuicao VARCHAR(255),
                        QtdItens INT,
                        ValorTabela DECIMAL(10, 2),
                        ValorPraticado DECIMAL(10, 2),
                        ValorLiquido DECIMAL(10, 2),
                        PRIMARY KEY (CodigoPedido, CodigoProduto),
                        FOREIGN KEY (CodigoPedido) REFERENCES pedidos(codigopedido) ON DELETE CASCADE
                    )
                """))
                conn.commit()
                print("Tabela 'itens_pedidos' criada/verificada com sucesso!")
        except Exception as e:
            print(f"Erro ao criar tabela: {e}")
            raise
        

    def inserirItensPedidos(self, itens_pedidos):
        try:
            # Normaliza para lista de dicts
            if hasattr(itens_pedidos, 'to_dict'):
                itens_pedidos = itens_pedidos.to_dict('records')

            colunas = [
                'CodigoPedido','CodigoProduto','Produto','DataCaptacao','CicloCaptacao',
                'DataFaturamento','CicloFaturamento','Pessoa','NomePessoa','Papel',
                'SituacaoFiscal','NotaFiscal','MeioCaptacao','CodPlanoPagamento','PlanoPagamento',
                'TipoEntrega','CodUsuarioCriacao','UsuarioCriacao','CodUsuarioFinalizacao',
                'UsuarioFinalizacao','CodCD','CanalDistribuicao','QtdItens',
                'ValorTabela','ValorPraticado','ValorLiquido'
            ]

            if not itens_pedidos:
                logger.info("Nenhum item recebido para processar.")
                return

            # Conexão RAW para usar execute_values
            conn = self.engine.raw_connection()
            cursor = conn.cursor()
            try:
                # 1) Garantimos que só inserimos itens cujos pedidos existem
                cursor.execute("SELECT DISTINCT codigopedido FROM pedidos")
                pedidos_existentes = {row[0] for row in cursor.fetchall()}
                batch = [i for i in itens_pedidos if i.get('CodigoPedido') in pedidos_existentes]
                if not batch:
                    logger.warning("Nenhum item com pedido existente encontrado.")
                    conn.rollback()
                    return

                values = [tuple(i.get(c) for c in colunas) for i in batch]

                # 2) Tabela temporária para este batch
                cursor.execute("""
                    CREATE TEMP TABLE tmp_itens_pedidos (
                        CodigoPedido varchar(30),
                        CodigoProduto varchar(30),
                        Produto VARCHAR(200),
                        DataCaptacao DATE,
                        CicloCaptacao VARCHAR(10),
                        DataFaturamento DATE,
                        CicloFaturamento VARCHAR(10),
                        Pessoa VARCHAR(30),
                        NomePessoa VARCHAR(255),
                        Papel VARCHAR(20),
                        SituacaoFiscal VARCHAR(40),
                        NotaFiscal VARCHAR(30),
                        MeioCaptacao VARCHAR(30),
                        CodPlanoPagamento VARCHAR(30),
                        PlanoPagamento VARCHAR(255),
                        TipoEntrega VARCHAR(30),
                        CodUsuarioCriacao VARCHAR(30),
                        UsuarioCriacao VARCHAR(255),
                        CodUsuarioFinalizacao VARCHAR(30),
                        UsuarioFinalizacao VARCHAR(255),
                        CodCD VARCHAR(30),
                        CanalDistribuicao VARCHAR(255),
                        QtdItens INT,
                        ValorTabela DECIMAL(10, 2),
                        ValorPraticado DECIMAL(10, 2),
                        ValorLiquido DECIMAL(10, 2)
                    ) ON COMMIT DROP
                """)

                # 3) Bulk load no staging
                execute_values(
                    cursor,
                    f"INSERT INTO tmp_itens_pedidos ({', '.join(colunas)}) VALUES %s",
                    values,
                    page_size=1000
                )

                # 4) Apagar itens cortados (somente dos pedidos presentes no batch)
                #    Remove toda linha da tabela principal cujo (Pedido,Produto) não está no staging
                cursor.execute("""
                    DELETE FROM itens_pedidos ip
                    USING (
                        SELECT DISTINCT CodigoPedido FROM tmp_itens_pedidos
                    ) p
                    WHERE ip.CodigoPedido = p.CodigoPedido
                    AND NOT EXISTS (
                        SELECT 1
                        FROM tmp_itens_pedidos t
                        WHERE t.CodigoPedido = ip.CodigoPedido
                            AND t.CodigoProduto = ip.CodigoProduto
                    )
                """)

                # 5) UPSERT dos válidos
                set_clause = ', '.join(
                    f"{c}=EXCLUDED.{c}" for c in colunas if c not in ('CodigoPedido','CodigoProduto')
                )
                cursor.execute(f"""
                    INSERT INTO itens_pedidos ({', '.join(colunas)})
                    SELECT {', '.join(colunas)} FROM tmp_itens_pedidos
                    ON CONFLICT (CodigoPedido, CodigoProduto)
                    DO UPDATE SET {set_clause}
                """)

                conn.commit()
                logger.info(f"Sincronização concluída: {len(batch)} itens válidos upsertados; itens cortados removidos.")
            except Exception as e:
                conn.rollback()
                logger.error(f"Erro na sincronização de itens: {e}")
                raise
            finally:
                cursor.close()
                conn.close()

        except Exception as e:
            logger.error(f"Erro ao inserir/atualizar itens de pedidos: {str(e)}")
            raise

    
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.engine:
                self.engine.dispose()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
    
    def consulta(self):
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT DISTINCT ciclocaptacao FROM pedidos"))
                return result
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise


class PegarGoogle():
    
    def __init__(self):
        logger.info("Inicializando PegarGoogle e o driver do Chrome...")
        self.driver = None
        self.wait = None
        self.data_formatada = None
        self.ciclo_1 = None
        self.ciclo_2 = None
        
        # Diretório de download personalizado
        base_dir = os.path.dirname(os.path.abspath(__file__))
        download_dir = os.path.join(base_dir, 'downloads')
        self.download_dir = download_dir
        
        # Garantir que o diretório de download existe
        os.makedirs(download_dir, exist_ok=True)

        try:
            logger.info("Configurando opções do Chrome")

            logger.info("Iniciando Chrome")
            
            driver = Driver(
                browser="chrome",
                uc=True,  # Usa undetected-chromedriver para evitar bloqueios de bot
                incognito=False,  # Ou use guest_mode=True se não quiser salvar nada
                locale_code="pt-BR",
                guest_mode=True,   
                disable_gpu=True, # Cria perfil novo, sem conta
                # headless=True,
                chromium_arg="--no-first-run,"
                    "--no-default-browser-check,"
                    "--disable-infobars,"
                    "--disable-popup-blocking,"
                    "--disable-extensions,"
                    "--disable-features=ChromeWhatsNewUI,"
                    "--disable-sync,"
                    "--disable-signin-promo,"
                    "--disable-background-networking,"
                    "--disable-features=SignInProfileCreation,ChromeSignin,"
            )
    
            driver.execute_cdp_cmd('Page.setDownloadBehavior', {
                'behavior': 'allow',
                'downloadPath': download_dir
            })

            self.driver = driver
            
            # Configurar comportamento de download via CDP
            self.driver.execute_cdp_cmd("Page.setDownloadBehavior", {
                "behavior": "allow",
                "downloadPath": download_dir
            })

            # Configurar wait com timeout mais longo (120s)
            logger.info("Configurando WebDriverWait com timeout de 120 segundos")
            self.wait = WebDriverWait(self.driver, 120)
            self.vars = {}
            
            # Maximizar a janela
            self.driver.maximize_window()
            logger.info("Setup do Selenium concluído")
            
            # Inicializar variáveis de ciclo
            self.ciclo = None
            
            actions = ActionChains(self.driver)
            self.actions = actions

        except Exception as e:
            logger.error(f"Erro ao inicializar o Chrome: {e}")
            if isinstance(e, WebDriverException):
                logger.error("Erro específico do WebDriver. Verifique se o Chrome está instalado corretamente.")
            self.fechar()
            raise
            
    def _esperar_e_clicar(self, by, valor, timeout=30):
        """Função auxiliar para esperar e clicar em elementos com retry"""
        logger.info(f"Tentando clicar no elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de clicar no elemento: {valor}")
                elemento = self.wait.until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].click();", elemento)
                logger.info(f"Clique bem-sucedido no elemento: {valor}")
                return True
            except Exception as e:
                if tentativa == 2:  # última tentativa 
                    logger.error(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def _esperar_elemento(self, by, valor, timeout=30):
        """Função auxiliar para esperar elementos com retry"""
        logger.info(f"Aguardando presença do elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de localizar o elemento: {valor}")
                elemento = self.wait.until(
                    EC.presence_of_element_located((by, valor))
                )
                logger.info(f"Elemento localizado com sucesso: {valor}")
                return elemento
            except Exception as e:
                if tentativa == 2:  # última tentativa
                    logger.error(f"Erro ao esperar elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def _switch_into_frame_with_element(self, by, locator, timeout=20):
        """Versão melhorada do método de switch para iframes"""
        try:
            logger.info("Voltando para o conteúdo principal")
            self.driver.switch_to.default_content()
            
            # Primeiro verificar se o elemento está no contexto principal
            try:
                elemento = WebDriverWait(self.driver, 5).until(
                    EC.presence_of_element_located((by, locator))
                )
                if elemento:
                    logger.info("Elemento encontrado no conteúdo principal")
                    return True
            except:
                pass  # Elemento não está no contexto principal
            
            # Procurar em todos os iframes
            iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
            logger.info(f"Encontrados {len(iframes)} iframes")
            
            for idx, frame in enumerate(iframes):
                try:
                    logger.info(f"Tentando iframe {idx}")
                    self.driver.switch_to.default_content()  # Reset sempre
                    self.driver.switch_to.frame(frame)
                    
                    # Aguardar conteúdo carregar
                    WebDriverWait(self.driver, 3).until(
                        EC.presence_of_element_located((By.TAG_NAME, "body"))
                    )
                    
                    # Verificar se elemento existe
                    elementos = self.driver.find_elements(by, locator)
                    if elementos:
                        logger.info(f"Elemento encontrado no iframe {idx}")
                        return True
                        
                except Exception as e:
                    logger.warning(f"Erro no iframe {idx}: {str(e)[:100]}")
                    continue
                    
            logger.warning("Elemento não encontrado em nenhum iframe")
            self.driver.switch_to.default_content()
            return False
            
        except Exception as e:
            logger.error(f"Erro geral ao procurar iframes: {e}")
            self.driver.switch_to.default_content()
            return False
                
    def entrar(self):
        try:
            self.driver.get(r"https://cp11143.retaguarda.grupoboticario.com.br/app/#/login")
                
            usuario = 'Mariliad02'
            senha = 'BotiWeb!'
            
            
            self._esperar_elemento(By.XPATH, r'//*[@id="input-19"]').send_keys(usuario)
            time.sleep(2)
            self._esperar_elemento(By.XPATH, r'//*[@id="input-20"]').send_keys(senha)
            
            time.sleep(2)
            self._esperar_e_clicar(By.XPATH, r'//*[@id="app"]/div[1]/section[2]/div/form/button')
            time.sleep(10)
            
            return True
            
        except ValueError as e:
            logger.error(f"Erro de validação ao fazer login: {str(e)}")
            logger.error("Verifique se as variáveis de ambiente vdUsername e vdPassword estão configuradas")
            return False
        except Exception as e:
            logger.error(f"Erro ao fazer login: {str(e)}", exc_info=True)
            return False
            
    def pegarABCVendas(self):
        try:
            logger.info("Iniciando processo de busca e exportação de pedidos")
            
            # Navegação inicial
            logger.info("Navegando para o menu de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="sidemenu-item-6"]/div')
            logger.info("Expandindo submenu")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="sidemenu-item-602"]')
            logger.info("Acessando consulta de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="sidemenu-item-144"]')
            time.sleep(3)
            
            # Garantir que estamos dentro do iframe correto
            alvo_xpath = r'//*[@id="select2-quebra-container"]'
            
            # Tentar entrar no iframe
            entrou_em_iframe = self._switch_into_frame_with_element(By.XPATH, alvo_xpath, timeout=20)
            
            if not entrou_em_iframe:
                logger.warning("Não foi possível entrar no iframe. Tentando alternativas...")
                self.driver.switch_to.default_content()
                iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                for iframe in iframes:
                    try:
                        self.driver.switch_to.frame(iframe)
                        elementos = self.driver.find_elements(By.XPATH, alvo_xpath)
                        if elementos:
                            logger.info("Elemento encontrado em iframe alternativo")
                            break
                    except:
                        self.driver.switch_to.default_content()
            
            
            data_inicial_xpath = r'//*[@id="periodoInicial"]'
            data_final_xpath = r'//*[@id="periodoFinal"]'
            
            # Limpar campos de data - CORREÇÃO AQUI
            
           
            # Preencher campos de data com a data atual
            data_hoje = date.today()
            data_ontem = data_hoje - timedelta(days=1)
            
            dataI = data_ontem.strftime("%d%m%Y")
            dataF = data_hoje.strftime("%d%m%Y")
            
            logger.info(f"Preenchendo datas: {dataI} a {dataF}")
            
            # CORREÇÃO: Usar os elementos já obtidos
            campo_inicial = self._esperar_elemento(By.XPATH, data_inicial_xpath)
            campo_final = self._esperar_elemento(By.XPATH, data_final_xpath)
            
            campo_inicial.clear()
            time.sleep(0.5)
            
            logger.info(f"Preenchendo datas: Início={dataI}, Fim={dataF}")
            
            campo_inicial.send_keys(Keys.HOME)
            time.sleep(0.5)
            
            campo_inicial.send_keys(dataI)
            time.sleep(1)
           
            campo_final.clear()
            time.sleep(0.5)
            
            campo_final.send_keys(Keys.HOME)
            time.sleep(0.5)
            
            campo_final.send_keys(dataF)
            time.sleep(1)
            
            self._esperar_e_clicar(By.XPATH, r'//*[@id="select2-quebra-container"]')
            
            self.actions.send_keys(Keys.TAB).perform()
            time.sleep(0.5)
            
            self.actions.send_keys(Keys.ENTER).perform()
            time.sleep(0.5)
            
            self.actions.send_keys("Data").perform()
            time.sleep(0.5)
            
            self.actions.key_down(Keys.SHIFT).send_keys(Keys.TAB).key_up(Keys.SHIFT).perform()
            time.sleep(0.5)
            
            self.actions.send_keys(Keys.ENTER).perform()
            time.sleep(0.5)
            
            self.actions.send_keys("Vendedor").perform()
            time.sleep(0.5)
                
        
            
            # # --- Para elementos Select2 ---
            # logger.info("Processando dropdown Select2")
            
            # # 1. Primeiro clique para abrir o dropdown
            # self._esperar_e_clicar(By.XPATH, alvo_xpath)
            # time.sleep(2)
            
            # # 2. Aguardar o dropdown abrir e localizar o campo de pesquisa
            # # O campo de pesquisa do Select2 geralmente tem a classe .select2-search__field
            # campo_pesquisa_xpath = "//input[@class='select2-search__field']"
            
            # # Aguardar o campo de pesquisa aparecer
            # campo_pesquisa = WebDriverWait(self.driver, 10).until(
            #     EC.presence_of_element_located((By.XPATH, campo_pesquisa_xpath))
            # )
            
            # # 3. Digitar "Data" no campo de pesquisa
            # campo_pesquisa.clear()
            # campo_pesquisa.send_keys("Data")
            # time.sleep(1)
            
            # # 4. Selecionar a opção (pressionar Enter ou clicar na opção)
            # campo_pesquisa.send_keys(Keys.ENTER)
            # time.sleep(2)
            
            # logger.info("Opção 'Data' selecionada com sucesso")
        
            # time.sleep(2)

            # time.sleep(5)
            
           
            # Clicar nos outros elementos
            logger.info("Clicando no segundo elemento")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="formulario"]/div/div/div[2]/div[2]/div/div/div[3]/div/label')
            time.sleep(2)
            
            logger.info("Clicando no terceiro elemento")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="formulario"]/div/div/div[2]/div[4]/div/div/div[2]/div/label')
            time.sleep(2)
            
            self._esperar_e_clicar(By.XPATH, r'//*[@id="exportar"]')
            time.sleep(2)
            
            # Voltar para o contexto principal após operações
            self.driver.switch_to.default_content()
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao pegar pedidos: {e}", exc_info=True)
            # Garantir que voltamos para o contexto principal em caso de erro
            try:
                self.driver.switch_to.default_content()
            except:
                pass
            raise
        
    
    def fecharJanela(self):
        logger.info("Tentando fechar janela secundária")
        try:
            logger.debug("Verificando número de janelas abertas")
            if WebDriverWait(self.driver, 10).until(EC.number_of_windows_to_be(2)):
                janelas = self.driver.window_handles
                logger.info(f"Detectadas {len(janelas)} janelas. Alternando para a janela secundária")
                self.driver.switch_to.window(janelas[1])
                logger.info("Fechando janela secundária")
                self.driver.close()
                logger.info("Voltando para a janela principal")
                self.driver.switch_to.window(janelas[0])
                logger.info("Janela secundária fechada com sucesso")
        except TimeoutException:
            logger.warning("Não foi detectada uma segunda janela para fechar")
        except Exception as e:
            logger.error(f"Erro ao fechar janela: {e}", exc_info=True)
            
    def pegar_downloads(self):
        wait = WebDriverWait(self.driver, 120)
        
        try:
            # Clique em vários elementos conforme necessário
            elements = [
                '//*[@id="agendamentoExportacao_exportarPanel"]/div/div/div[2]/div[1]/div/div/div[2]/ul/li[2]/a',
                '//*[@id="agendamentoExportacao_colunasTab"]/div[1]/div/div/label',
                '//*[@id="agendamentoExportacao_divIncluirDadosPessoais"]/label',
                '//*[@id="popupOkButton"]',
                '//*[@id="agendamentoExportacao_okButton_B1"]',
                '//*[@id="popupOkButton"]',
                '//*[@id="menu-cod-8"]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/ul/li[3]/a'
            ]
            
            
            for xpath in elements:
                element = wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
                self.driver.execute_script("arguments[0].click();", element)
                time.sleep(2)  # Adicione um tempo de espera se necessário
            
            # Código específico para clicar no botão de download com tratamento de exceção
            while True:
                try:
                    download_button = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_exportacoesGrid_baixarButton_0_btn_0"]')))
                    time.sleep(10)
                    self.driver.execute_script("arguments[0].click();", download_button)
                    time.sleep(10)
                    break  # Sai do loop se conseguir clicar no botão de download
                except TimeoutException:
                    # Verifica se o botão de alerta está presente
                    try:
                        alert_button = self.driver.find_element('xpath', '//*[@id="msgAlert"]')
                        if alert_button.is_displayed():
                            logger.info("Alerta detectado. Recarregando a página...")
                            self.driver.refresh()  # Recarrega a página
                            time.sleep(5)  # Aguarda um tempo para a página recarregar
                            continue  # Volta para o início do loop
                    except NoSuchElementException:
                        pass  # Se o alerta não for encontrado, continua com a próxima tentativa
                except StaleElementReferenceException:
                    # Tenta buscar o elemento novamente se ocorrer StaleElementReferenceException
                    logger.info("Elemento desatualizado detectado. Tentando buscar novamente...")
                    continue

                # Tentar clicar no botão de atualizar se o botão de download não estiver disponível
                try:
                    atualizar = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_atualizarButton_btn"]')))
                    self.driver.execute_script("arguments[0].click();", atualizar)
                    time.sleep(5)  # Adiciona um pequeno tempo de espera para o botão ser clicado
                except TimeoutException:
                    pass
        except StaleElementReferenceException:
            logger.info("Elemento foi atualizado ou não está mais na página. Recarregando...")
            self.driver.refresh()  # Recarrega a página
            time.sleep(5)
            self.pegar_downloads()  # Tenta novamente
            
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.driver:
                self.driver.quit()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
            
if __name__ == "__main__":
    
    logger.info("Iniciando execução principal do script Pedidos.py")
    
    rpa = PegarGoogle()
    while rpa.entrar():
        logger.info("Chamando método pegarItensVendas()")
        if rpa.pegarABCVendas():
            break
    
    # logger.info("Execução principal finalizada")
    # banco = Banco()
    # banco.criar_tabela()
    # banco.fechar()

    # tratar = TratarDados()
    # df = tratar.processar_arquivo_abc_vendas()
    # df.to_excel("abc_vendas.xlsx", index=False)
    
    
    # banco.inserirItensPedidos(df)

    # banco.fechar()
    # rpa.fechar()
    
