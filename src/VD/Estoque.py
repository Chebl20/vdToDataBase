# Generated by Selenium IDE
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException,NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service 
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime, timedelta
import pandas as pd
import glob
import os
import numpy as np
from urllib.parse import quote
from sqlalchemy import create_engine, text
from sqlalchemy.types import String
from sqlalchemy.types import Integer
from sqlalchemy.types import Float
from sqlalchemy.types import DateTime
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException
import chromedriver_autoinstaller
from dotenv import load_dotenv
import logging
import io
import csv
from pandas.api.types import is_scalar
import psycopg2.extras
import openpyxl 


# Carregando variáveis de ambiente do arquivo .env
load_dotenv()

ciclos_2025 = [
    {"ciclo": 1, "inicio": "26/12/2024", "fim": "19/01/2025"},
    {"ciclo": 2, "inicio": "20/01/2025", "fim": "09/02/2025"},
    {"ciclo": 3, "inicio": "10/02/2025", "fim": "02/03/2025"},
    {"ciclo": 4, "inicio": "03/03/2025", "fim": "23/03/2025"},
    {"ciclo": 5, "inicio": "24/03/2025", "fim": "13/04/2025"},
    {"ciclo": 6, "inicio": "14/04/2025", "fim": "11/05/2025"},
    {"ciclo": 7, "inicio": "12/05/2025", "fim": "25/05/2025"},
    {"ciclo": 8, "inicio": "26/05/2025", "fim": "12/06/2025"},
    {"ciclo": 9, "inicio": "13/06/2025", "fim": "29/06/2025"},
    {"ciclo": 10, "inicio": "30/06/2025", "fim": "20/07/2025"},
    {"ciclo": 11, "inicio": "21/07/2025", "fim": "10/08/2025"},
    {"ciclo": 12, "inicio": "11/08/2025", "fim": "31/08/2025"},
    {"ciclo": 13, "inicio": "01/09/2025", "fim": "21/09/2025"},
    {"ciclo": 14, "inicio": "22/09/2025", "fim": "12/10/2025"},
    {"ciclo": 15, "inicio": "13/10/2025", "fim": "02/11/2025"},
    {"ciclo": 16, "inicio": "03/11/2025", "fim": "30/11/2025"},
    {"ciclo": 17, "inicio": "01/12/2025", "fim": "25/12/2025"},
]

import glob
import os
import logging
import pandas as pd
from typing import Dict, List, Optional, Tuple, Union

class TratarDados:
    """Classe para tratamento de dados de vendas a partir de arquivos XLS, XLSX, CSV ou TXT."""
    
    # Mapeamento de colunas esperadas e seus limites
    COLUNAS_ESPERADAS = {
        'Código Produto': ('CodigoProduto', 10),
        'Nome Produto': ('NomeProduto', 50),
        'Cód Est Pai': ('CodEstPai', 20),
        'Estrutura Pai': ('EstruturaPai', 20),
        'CodEstCom': ('CodEstCom', 20),
        'NomeEstCom': ('NomeEstCom', 20),
        'Responsável Est Com': ('ResponsavelEstCom', 20),
        'Quantidade': ('Quantidade', None),  # Numérico, sem limite de string
        'Código Pedido': ('CodigoPedido', 20),
        'Código Pessoa': ('CodigoPessoa', 20),
        'Nome Pessoa': ('NomePessoa', 50),
        'Data Pedido': ('DataPedido', None),  # Data, sem limite de string
        'Ciclo': ('Ciclo', 10),
        'SubCiclo': ('SubCiclo', 10),
        'Situação pedido': ('SituacaoPedido', 30),
        'Nome Modelo Comercial': ('NomeModeloComercial', 1000)
    }
    
    def __init__(self, caminho_padrao: Optional[str] = None):
        """
        Inicializa a classe com o caminho padrão ou usa o caminho padrão do sistema.
        
        Args:
            caminho_padrao: Caminho opcional para buscar os arquivos. Se None, usa o padrão.
        """
        base_dir = os.path.dirname(os.path.abspath(__file__))
        caminho = caminho_padrao or os.path.join(base_dir, 'downloads', 'BuscarPedidosItensAnalitico_*.xls')
        self._encontrar_arquivo_mais_recente(caminho)
    
    def _encontrar_arquivo_mais_recente(self, caminho: str):
        """Encontra o arquivo mais recente no caminho especificado."""
        list_of_files = glob.glob(caminho)
        if not list_of_files:
            raise FileNotFoundError(f"Nenhum arquivo 'BuscarPedidosItensAnalitico_*.xls' encontrado em {caminho}.")
        self.file = max(list_of_files, key=os.path.getctime)
        logging.info(f"Arquivo selecionado para processamento: {self.file}")
    
    def processar_arquivo_vendas(self) -> pd.DataFrame:
        """Processa o arquivo de vendas e retorna um DataFrame tratado."""
        try:
            logging.info(f"Iniciando processamento do arquivo: {self.file}")
            
            # Leitura do arquivo
            df = self._ler_arquivo()
            
            # Validação básica
            self._validar_estrutura_arquivo(df)
            
            # Renomear colunas
            df = self._renomear_colunas(df)
            
            # Processamento de dados
            df = self._processar_datas(df)
            df = self._processar_numericos(df)
            df = self._truncar_colunas(df)
            df = self._remover_pontos_codigos(df)
            
            # Validação final
            self._validar_dados(df)
            
            logging.info("Processamento concluído com sucesso")
            return df
            
        except Exception as e:
            logging.error(f"Erro ao processar arquivo: {str(e)}", exc_info=True)
            raise
    
    def _ler_arquivo(self) -> pd.DataFrame:
        """Lê o arquivo de acordo com seu formato."""
        extensao = os.path.splitext(self.file)[-1].lower()
        
        if extensao in ['.xls', '.xlsx']:
            logging.info("Lendo arquivo Excel")
            return pd.read_excel(self.file, dtype=str)
        
        elif extensao in ['.csv', '.txt']:
            logging.info("Lendo arquivo texto")
            self._validar_arquivo_texto()
            return pd.read_csv(
                self.file, 
                sep='|', 
                quotechar='"', 
                encoding='utf-8', 
                engine='python', 
                on_bad_lines='warn', 
                dtype=str
            )
        
        raise ValueError(f"Formato de arquivo não suportado: {extensao}")
    
    def _validar_arquivo_texto(self) -> None:
        """Valida a estrutura do arquivo texto antes da leitura."""
        linhas_invalidas = []
        with open(self.file, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f):
                parts = line.strip().split('|')
                if len(parts) != 17:
                    linhas_invalidas.append((i + 1, len(parts), line.strip()))
        
        if linhas_invalidas:
            logging.warning(f"Linhas inválidas encontradas: {len(linhas_invalidas)}")
            for linha in linhas_invalidas[:5]:
                logging.warning(f"Linha {linha[0]}: {linha[1]} colunas - Conteúdo: {linha[2]}")
            if len(linhas_invalidas) > 5:
                logging.warning(f"...e mais {len(linhas_invalidas) - 5} linhas com problemas.")
    
    def _validar_estrutura_arquivo(self, df: pd.DataFrame) -> None:
        """Valida a estrutura básica do DataFrame."""
        if len(df.columns) < 10:
            error_msg = f"Arquivo com colunas insuficientes. Encontradas: {len(df.columns)}"
            logging.error(error_msg)
            logging.error(f"Colunas encontradas: {df.columns.tolist()}")
            raise ValueError(error_msg)
        
        colunas_faltantes = [
            col for col in self.COLUNAS_ESPERADAS 
            if col not in df.columns
        ]
        
        if colunas_faltantes:
            logging.warning(f"Colunas esperadas não encontradas: {colunas_faltantes}")
    
    def _renomear_colunas(self, df: pd.DataFrame) -> pd.DataFrame:
        """Renomeia as colunas conforme o mapeamento."""
        mapeamento = {
            original: novo[0] 
            for original, novo in self.COLUNAS_ESPERADAS.items() 
            if original in df.columns
        }
        return df.rename(columns=mapeamento)
    
    def _processar_datas(self, df: pd.DataFrame) -> pd.DataFrame:
        """Processa a coluna de datas com múltiplos formatos e validação rigorosa.
        
        Args:
            df: DataFrame contendo a coluna 'DataPedido' a ser processada
            
        Returns:
            DataFrame com a coluna 'DataPedido' convertida para datetime ou None para valores inválidos
        """
        if 'DataPedido' not in df.columns:
            return df
            
        # Registrar formato original para debug
        logging.debug(f"Tipos originais: {df['DataPedido'].dtype}")
        logging.debug(f"5 primeiros valores originais:\n{df['DataPedido'].head()}")
        
        # Lista de formatos a serem tentados (em ordem de prioridade)
        formatos = [
            None,  # Auto-detect (funciona para ISO)
            '%d/%m/%Y %H:%M:%S.%f',  # Com milissegundos
            '%d/%m/%Y %H:%M:%S',     # Com segundos
            '%d/%m/%Y %H:%M',        # Com minutos
            '%d/%m/%Y',              # Apenas data
            '%Y-%m-%d %H:%M:%S.%f',  # ISO com milissegundos
            '%Y-%m-%d %H:%M:%S',     # ISO com segundos
            '%Y-%m-%d %H:%M',        # ISO com minutos
            '%Y-%m-%d',              # ISO apenas data
            '%m/%d/%Y %H:%M:%S',     # Formato americano (mês/dia)
        ]
        
        # Inicializa a coluna convertida como None
        df['DataPedido_convertida'] = None
        
        for fmt in formatos:
            # Quantidade de valores ainda não convertidos
            mask_na = df['DataPedido_convertida'].isna()
            if not mask_na.any():
                break
                
            # Tentar conversão com o formato atual
            try:
                if fmt:
                    # Conversão com formato específico
                    df.loc[mask_na, 'DataPedido_convertida'] = pd.to_datetime(
                        df.loc[mask_na, 'DataPedido'],
                        format=fmt,
                        errors='coerce',
                        dayfirst=fmt.startswith('%d/') if fmt else False
                    )
                else:
                    # Auto-detecção (sem formato específico)
                    df.loc[mask_na, 'DataPedido_convertida'] = pd.to_datetime(
                        df.loc[mask_na, 'DataPedido'],
                        errors='coerce'
                    )
            except Exception as e:
                logging.warning(f"Erro ao tentar formato {fmt}: {str(e)}")
                continue
                
            # Log de progresso
            converted = mask_na.sum() - df['DataPedido_convertida'].isna().sum()
            if converted > 0 and fmt:
                logging.debug(f"Formato {fmt} converteu {converted} valores")
        
        # Substituir a coluna original pela convertida
        df['DataPedido'] = df['DataPedido_convertida']
        df.drop(columns=['DataPedido_convertida'], inplace=True)
        
        # Verificação final
        self._validar_conversao_datas(df)
        
        return df

    def _validar_conversao_datas(self, df: pd.DataFrame) -> None:
        """Realiza validações rigorosas na conversão de datas."""
        # Contagem de valores não convertidos
        nat_count = df['DataPedido'].isna().sum()
        total = len(df)
        
        if nat_count > 0:
            # Coletar exemplos de valores problemáticos
            problematicos = df[df['DataPedido'].isna()]['DataPedido'].unique()[:10]
            percentual = (nat_count / total) * 100
            
            logging.warning(f"ATENÇÃO: {nat_count} de {total} valores não convertidos ({percentual:.2f}%)")
            logging.warning(f"Exemplos de valores problemáticos: {problematicos.tolist()}")
            
            # Criar relatório detalhado em arquivo se muitos erros
            if percentual > 1:  # Mais de 1% de erros
                self._gerar_relatorio_erros_datas(df)
        
        # Verificar datas fora de um intervalo razoável
        if not df['DataPedido'].isna().all():
            min_date = df['DataPedido'].min()
            max_date = df['DataPedido'].max()
            logging.info(f"Intervalo de datas convertidas: {min_date} até {max_date}")
            
            # Verificar datas muito antigas ou futuras
            ano_atual = pd.Timestamp.now().year
            if min_date.year < (ano_atual - 10) or max_date.year > (ano_atual + 1):
                logging.warning(f"Possíveis datas inconsistentes: mínimo={min_date}, máximo={max_date}")

    def _gerar_relatorio_erros_datas(self, df: pd.DataFrame) -> None:
        """Gera um relatório CSV com os valores que não puderam ser convertidos."""
        try:
            df_erros = df[df['DataPedido'].isna()][['DataPedido']].copy()
            df_erros['Valor Original'] = df[df['DataPedido'].isna()]['DataPedido']
            
            nome_arquivo = f"erros_conversao_datas_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df_erros.to_csv(nome_arquivo, index=False)
            
            logging.warning(f"Relatório de erros de conversão salvo em: {nome_arquivo}")
        except Exception as e:
            logging.error(f"Falha ao gerar relatório de erros: {str(e)}")
    
    def _processar_numericos(self, df: pd.DataFrame) -> pd.DataFrame:
        """Processa colunas numéricas."""
        if 'Quantidade' in df.columns:
            df['Quantidade'] = (
                pd.to_numeric(df['Quantidade'], errors='coerce')
                .fillna(0)
                .astype(int)
            )
        return df
    
    def _truncar_colunas(self, df: pd.DataFrame) -> pd.DataFrame:
        """Trunca as colunas de texto conforme os limites definidos."""
        for col in df.columns:
            if col in [novo[0] for novo in self.COLUNAS_ESPERADAS.values() if novo[1]]:
                limite = next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)
                df[col] = (
                    df[col]
                    .fillna('')
                    .apply(lambda x: str(x).strip()[:limite] if x is not None else '')
                    .replace('', None)
                )
        return df
    
    def _remover_pontos_codigos(self, df: pd.DataFrame) -> pd.DataFrame:
        """Remove pontos de códigos e aplica truncamento."""
        for col in ['CodigoPedido', 'CodigoProduto', 'CodigoPessoa']:
            if col in df.columns:
                df[col] = (
                    df[col]
                    .fillna('')
                    .apply(lambda x: x.replace('.', '')[:next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)] if x else '')
                    .replace('', None)
                )
        return df
    
    def _validar_dados(self, df: pd.DataFrame) -> None:
        """Realiza validações finais nos dados."""
        # Verificar valores longos
        for col in df.columns:
            if col in [novo[0] for novo in self.COLUNAS_ESPERADAS.values() if novo[1]]:
                limite = next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)
                valores_longos = df[col].dropna().apply(lambda x: len(str(x)) > limite)
                if valores_longos.any():
                    logging.warning(f"Coluna {col} tem {valores_longos.sum()} valores excedendo o limite de {limite} caracteres")
        
        # Verificar valores nulos em colunas importantes
        for col in ['CodigoProduto', 'CodigoPedido', 'Quantidade']:
            if col in df.columns and df[col].isna().any():
                logging.warning(f"Coluna {col} contém valores nulos")

# Configurar logging
logging.basicConfig(level=logging.INFO)

class Banco:
    def __init__(self):
        self.engine = create_engine(os.getenv('dbUrlConnect'))
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                if result.scalar() == 1:
                    logging.info("Conectado ao banco com sucesso!")
                    self.criar_tabela()
                else:
                    logging.error("Erro ao conectar ao banco.")
        except Exception as e:
            logging.error(f"Erro ao conectar ao banco: {e}")
            raise

    def criar_tabela(self):
        try:
            with self.engine.begin() as conn:
                conn.execute(text("""
                    CREATE TABLE IF NOT EXISTS itens_pedido (
                        id SERIAL PRIMARY KEY,
                        codigo_produto VARCHAR(10),
                        nome_produto TEXT,
                        cod_est_pai VARCHAR(10),
                        estrutura_pai TEXT,
                        cod_est_com VARCHAR(10),
                        nome_est_com TEXT,
                        responsavel_est_com VARCHAR(20),
                        quantidade INTEGER,
                        codigopedido VARCHAR(20),
                        codigo_pessoa VARCHAR(20),
                        nome_pessoa TEXT,
                        data_pedido TIMESTAMP,
                        ciclo VARCHAR(10),
                        subciclo VARCHAR(10),
                        situacao_pedido VARCHAR(20),
                        nome_modelo_comercial TEXT,
                        UNIQUE (codigopedido, codigo_produto),
                        FOREIGN KEY (codigopedido) REFERENCES pedidos(CodigoPedido)
                    );
                """))
                logging.info("Tabela 'itens_pedido' criada/verificada com sucesso!")
        except Exception as e:
            logging.error(f"Erro ao criar tabela: {e}")
            raise
         

    def inserirItensPedido(self, itens):
        try:
            itens.to_excel('itens_pedido_ant_ren.xlsx', index=False)
            
            itens = itens.rename(columns={
                "CodigoPedido": "codigopedido",
                "CodigoProduto": "codigo_produto",
                "NomeProduto": "nome_produto",
                "CodEstPai": "cod_est_pai",
                "EstruturaPai": "estrutura_pai",
                "CodEstCom": "cod_est_com",
                "NomeEstCom": "nome_est_com",
                "ResponsavelEstCom": "responsavel_est_com",
                "Quantidade": "quantidade",
                "CodigoPessoa": "codigo_pessoa",
                "NomePessoa": "nome_pessoa",
                "DataPedido": "data_pedido",
                "Ciclo": "ciclo",
                "SubCiclo": "subciclo",
                "SituacaoPedido": "situacao_pedido",
                "NomeModeloComercial": "nome_modelo_comercial"
            })
            
            
            if hasattr(itens, 'to_dict'):
                itens = itens.to_dict('records')
                
            colunas = [
                "codigopedido", "codigo_produto", "nome_produto", "cod_est_pai", "estrutura_pai",
                "cod_est_com", "nome_est_com", "responsavel_est_com", "quantidade", "codigo_pessoa",
                    "nome_pessoa", "data_pedido", "ciclo", "subciclo", "situacao_pedido", "nome_modelo_comercial"
                ]

            values = [tuple(item.get(col, None) for col in colunas) for item in itens]

            insert_query = f"""
                INSERT INTO itens_pedido ({', '.join(colunas)})
                VALUES ({', '.join(['%s'] * len(colunas))})
                ON CONFLICT (codigopedido, codigo_produto)
                    DO UPDATE SET
                        {', '.join([f"{col} = EXCLUDED.{col}" for col in colunas if col not in ['codigopedido', 'codigo_produto']])}
                """

            conn = self.engine.raw_connection()
            cursor = conn.cursor()
            try:
                psycopg2.extras.execute_batch(cursor, insert_query, values)
                conn.commit()
                logging.info("Inserção/atualização de itens de pedido concluída com sucesso.")
            except Exception as e:
                conn.rollback()
                logging.error(f"Erro ao inserir/atualizar itens de pedido: {e}")
                raise
            finally:
                cursor.close()
                conn.close()

        except Exception as e:
            logging.error(f"Erro ao preparar dados dos itens de pedido: {e}")
            raise

    def fechar(self):
        """Método para fechar a conexão com o banco"""
        try:
            if self.engine:
                self.engine.dispose()
                logging.info("Conexão com o banco encerrada.")
        except Exception as e:
            logging.error(f"Erro ao fechar a conexão com o banco: {e}")

class PegarGoogle:
    """
    Classe para automatizar interações com o sistema SGI e-Boticario,
    realizando login, extração de dados de vendas e download de relatórios.
    """
    
    def __init__(self):
        """Inicializa o driver do Chrome com download automático da versão correta."""
        self.driver = None
        self.wait = None
        self.data_formatada = None
        self.ciclo_1 = None
        self.ciclo_2 = None

        try:
            # Configuração das opções do Chrome
            options = Options()
            options.add_argument('--start-maximized')
            options.add_argument('--disable-extensions')
            options.add_argument('--disable-gpu')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_experimental_option('excludeSwitches', ['enable-logging'])
            options.add_experimental_option('detach', True)

            # Configuração para downloads automáticos
            prefs = {
                "download.default_directory": os.path.join(os.getcwd(), "downloads"),
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": True
            }
            options.add_experimental_option("prefs", prefs)

            print("Iniciando Chrome com driver automático")
            self.driver = webdriver.Chrome(
                service=Service(ChromeDriverManager().install()),
                options=options
            )
            self.wait = WebDriverWait(self.driver, 30)

            self.driver.maximize_window()
            self._configurar_data_e_ciclos()

        except Exception as e:
            print(f"Erro ao inicializar o Chrome: {e}")
            if isinstance(e, WebDriverException):
                print("Erro específico do WebDriver. Verifique se o Chrome está instalado corretamente.")
            self.fechar()
            raise
    
    def _configurar_data_e_ciclos(self):
        """Configura a data de ontem e identifica os ciclos correspondentes."""
        data_de_ontem = self.diaOntem()
        self.data_formatada = data_de_ontem.strftime('%d%m%Y')
        
        # Identificar ciclos
        ciclo_atual, ciclo_anterior = self._identificar_ciclos(data_de_ontem)
        
        # Formatar os ciclos como strings com dois dígitos
        self.ciclo_1 = f"{ciclo_atual['ciclo']:02d}" if ciclo_atual else None
        self.ciclo_2 = f"{ciclo_anterior['ciclo']:02d}" if ciclo_anterior else None
        
        print(f"Ciclos identificados: atual={self.ciclo_1}, anterior={self.ciclo_2}")
    
    def _identificar_ciclos(self, data):
        """
        Identifica o ciclo atual e o anterior com base na data fornecida.
        
        Args:
            data (datetime): Data para identificação dos ciclos
            
        Returns:
            tuple: (ciclo_atual, ciclo_anterior)
        """
        ciclo_atual = None
        ciclo_anterior = None

        # Primeiro passo: encontrar o ciclo onde a data atual se encaixa
        for ciclo in ciclos_2025:
            inicio = datetime.strptime(ciclo["inicio"], "%d/%m/%Y")
            fim = datetime.strptime(ciclo["fim"], "%d/%m/%Y")
            
            if inicio <= data <= fim:
                ciclo_atual = ciclo
                break
        
        # Segundo passo: encontrar o ciclo anterior
        if ciclo_atual:
            # Se encontramos um ciclo atual, precisamos do imediatamente anterior
            indice_atual = ciclos_2025.index(ciclo_atual)
            if indice_atual > 0:  # Se não for o primeiro ciclo
                ciclo_anterior = ciclos_2025[indice_atual - 1]
        else:
            # Se não encontramos um ciclo atual (estamos entre ciclos ou após o último)
            for ciclo in reversed(ciclos_2025):
                fim = datetime.strptime(ciclo["fim"], "%d/%m/%Y")
                if data > fim:
                    ciclo_atual = ciclo
                    indice_atual = ciclos_2025.index(ciclo)
                    if indice_atual > 0:
                        ciclo_anterior = ciclos_2025[indice_atual - 1]
                    break
        
        return ciclo_atual, ciclo_anterior
    
    def diaOntem(self):
        """Retorna a data de ontem como objeto datetime."""
        return datetime.today() - timedelta(days=1)
    
    def _esperar_exportar(self, by, valor, timeout=60, tentativas=60):
        """
        Função auxiliar para esperar e clicar em elementos com retry."""
        
        for tentativa in range(tentativas):
            try:
                elemento = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", elemento)
                time.sleep(0.5)  # Pequena pausa para garantir visibilidade
                self.driver.execute_script("arguments[0].click();", elemento)
                return True
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    print(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                print(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _esperar_e_clicar(self, by, valor, timeout=30, tentativas=3):
        """
        Função auxiliar para esperar e clicar em elementos com retry.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            timeout: Tempo máximo de espera em segundos
            tentativas: Número de tentativas
            
        Returns:
            bool: True se o clique foi bem-sucedido
        """
        for tentativa in range(tentativas):
            try:
                elemento = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", elemento)
                time.sleep(0.5)  # Pequena pausa para garantir visibilidade
                self.driver.execute_script("arguments[0].click();", elemento)
                return True
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    print(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                print(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _esperar_elemento(self, by, valor, timeout=30, tentativas=3):
        """
        Função auxiliar para esperar elementos com retry.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            timeout: Tempo máximo de espera em segundos
            tentativas: Número de tentativas
            
        Returns:
            WebElement: O elemento encontrado
        """
        for tentativa in range(tentativas):
            try:
                return self.wait.until(
                    EC.element_to_be_clickable((by, valor))
                )
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    print(f"Erro ao esperar elemento {valor}: {e}")
                    raise
                print(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _preencher_campo(self, by, valor, texto, limpar=True):
        """
        Preenche um campo de texto com o valor especificado.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            texto: Texto a ser inserido
            limpar: Se True, limpa o campo antes de preencher
        """
        elemento = self._esperar_elemento(by, valor)
        if limpar:
            elemento.clear()
        elemento.send_keys(texto)
    
    def entrar(self):
        """
        Realiza o login no sistema.
        
        Returns:
            bool: True se o login foi bem-sucedido
        """
        try:
            usuario = os.getenv('vdUsername')
            senha = os.getenv('vdPassword')
            
            if not usuario or not senha:
                raise ValueError("Credenciais não encontradas nas variáveis de ambiente")
            
            print("Acessando página de login...")
            self.driver.get("https://sgi.e-boticario.com.br/Paginas/Acesso/Entrar.aspx?ReturnUrl=%2f")
            
            # Preenchendo credenciais
            self._preencher_campo(By.ID, "username", usuario)
            self._preencher_campo(By.ID, "password", senha)
            
            # Clicando no botão de login
            self._esperar_e_clicar(By.ID, "btnLogin")
            
            # Aguardando login completar
            self._esperar_elemento(By.ID, "menu-cod-1")
            
            print("Login realizado com sucesso!")
            return True
            
        except Exception as e:
            print(f"Erro ao fazer login: {str(e)}")
            if isinstance(e, ValueError):
                print("Verifique se as variáveis de ambiente vdUsername e vdPassword estão configuradas")
            return False
    
    def tratarErroPainel(self, timeout=10):
        """
        Verifica e trata erros de painéis que podem aparecer.
        
        Args:
            timeout: Tempo máximo de espera em segundos
        
        Returns:
            bool: True se não houver erro ou se o erro foi tratado com sucesso
        """
        try:
            # Tenta localizar o botão OK em painéis de erro
            mensagem_painel = WebDriverWait(self.driver, timeout).until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="popupOkButton"]'))
            )
            
            if mensagem_painel.is_displayed():
                print("Painel de erro detectado. Tentando resolver...")
                mensagem_painel.click()
                print("Painel de erro fechado.")
                return False  # Indica que um erro foi detectado e tratado
            
        except TimeoutException:
            # Painel não apareceu, o que é bom
            return True
        except Exception as e:
            print(f"Erro ao tratar painel: {e}")
            return False
    
    def pegarVendas(self):
        """
        Navega pelo sistema para extrair dados de vendas.
        
        Returns:
            bool: True se a operação foi bem-sucedida
        """
        try:
            # Navegar para o menu de vendas
            self._esperar_e_clicar(By.XPATH, '//*[@id="menu-cod-1"]/a')
            time.sleep(1)
            self._esperar_e_clicar(By.XPATH, '//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/a')
            time.sleep(1)
            self._esperar_e_clicar(By.XPATH, '//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/ul/li[4]/a')
            time.sleep(1)
            
            # Preencher os filtros de relatório
            # self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]')
            # time.sleep(6)
            # self._preencher_campo(By.XPATH, r'//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]', "na")
            # self._preencher_campo(By.XPATH, r'//*[@id="ContentPlaceHolder1_seletorBuscaDropDown_d1"]', "por")
            
            
            element = self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]').send_keys("na")
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_seletorBuscaDropDown_d1"]').send_keys("por")
            
            # Preencher datas
            time.sleep(2)
            self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_dataInicioTextBox_T2"]', self.data_formatada)
            time.sleep(2)
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_dataTerminoTextBox_T2"]')))
            self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_dataTerminoTextBox_T2"]', self.data_formatada)
            
            # Preencher ciclos
            # self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]')))
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]', self.ciclo_2)
            # time.sleep(2)
            
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]').send_keys(self.ciclo_2)
            time.sleep(3)
            
            # self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]')))
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]', self.ciclo_1)
            # time.sleep(2)
            
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]').send_keys(self.ciclo_1)
            time.sleep(5)
            # Preencher tipo de item
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_tipoItemPedidoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_tipoItemPedidoDropDown_d1"]').send_keys("ve")
            
            # Configurar tipo de busca
            tipo_busca = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="ContentPlaceHolder1_tipoBuscaItemDropDown_d1"]'))
            )
            tipo_busca.send_keys(Keys.RIGHT)
            tipo_busca.send_keys(Keys.RIGHT)
            time.sleep(0.5)
            
            # Configurar tipo de relatório
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_tipoRelatProdutoDropDown_d1"]')))
            self.driver.find_element(By.XPATH, '//*[@id="ContentPlaceHolder1_tipoRelatProdutoDropDown_d1"]').send_keys("an")
            
            # Clicar em buscar
            self._esperar_e_clicar(By.XPATH, '//*[@id="ContentPlaceHolder1_buscarButton_btn"]')
            
            # Verificar se houve erro
            if not self.tratarErroPainel():
                return False
            
            # Aguardar carregamento dos resultados
            time.sleep(10)
            
            # Clicar no botão de exportar
            self._esperar_exportar(By.XPATH, '//*[@id="ContentPlaceHolder1_exportarButton2_btn"]')
            
            self._esperar_e_clicar(By.XPATH, '//*[@id="tab-01"]/div[3]/div/div[2]/div/div[1]/span/label')
            
            # Capturar informações de resultados se necessário
            try:
                elemento_info = self.driver.find_element(By.XPATH, '//*[@id="ContentPlaceHolder1_pnlTextoResultado"]/span/b')
                texto_info = elemento_info.text
                print(f"Informações dos resultados: {texto_info}")
            except:
                pass
            
            # Configurar a exportação
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_exportarPanel"]/div/div/div[2]/div[1]/div/div/div[2]/ul/li[2]/a')
            time.sleep(2)
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_colunasTab"]/div[1]/div/div/label')
            time.sleep(2)
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_okButton_B1"]')
            
            # Aguardar botão OK do popup e fechar janela
            self._esperar_e_clicar(By.XPATH, '//*[@id="popupOkButton"]')
            time.sleep(3)
            
            # Realizar download do arquivo
            self.pegar_downloads()
            
            # Esperar download concluído
            self.esperar_download_concluido()
            
            # Fechar janelas extras
            self.fecharJanela()
            
            return True
        except Exception as e:
            print(f"Erro na função vendas: {e}")
            return False
    
    def fecharJanela(self):
        """Fecha qualquer janela extra aberta pelo sistema."""
        try:
            # Verificar se existem múltiplas janelas abertas
            janelas = self.driver.window_handles
            if len(janelas) > 1:
                # Muda para a segunda janela e a fecha
                self.driver.switch_to.window(janelas[1])
                self.driver.close()
                # Volta para a janela principal
                self.driver.switch_to.window(janelas[0])
                print("Janela extra fechada com sucesso")
        except Exception as e:
            print(f"Erro ao fechar janela: {e}")
    
    def esperar_download_concluido(self, diretorio="downloads", timeout=300):
        """
        Espera até que um arquivo seja baixado completamente.
        
        Args:
            diretorio: Caminho para o diretório de download
            timeout: Tempo máximo de espera em segundos
        
        Returns:
            str: Caminho do arquivo baixado ou None se falhar
        """
        # Garantir que o diretório existe
        os.makedirs(diretorio, exist_ok=True)
        
        inicio = time.time()
        ultimo_tamanho = {}
        arquivo_baixado = None
        
        print("Aguardando conclusão do download...")
        
        while time.time() - inicio < timeout:
            # Busca por arquivos parcialmente baixados
            arquivos_parciais = glob.glob(os.path.join(diretorio, "*.crdownload")) + \
                               glob.glob(os.path.join(diretorio, "*.part")) + \
                               glob.glob(os.path.join(diretorio, "*.download"))
            
            # Se não há arquivos parciais, verifica por novos arquivos completos
            if not arquivos_parciais:
                arquivos = glob.glob(os.path.join(diretorio, "*"))
                if arquivos:
                    # Pega o arquivo mais recente (assumindo que é o download atual)
                    arquivo_recente = max(arquivos, key=os.path.getctime)
                    
                    # Se o arquivo não mudou de tamanho nos últimos 3 segundos
                    # assume que o download está completo
                    tamanho_atual = os.path.getsize(arquivo_recente)
                    if arquivo_recente in ultimo_tamanho:
                        if tamanho_atual == ultimo_tamanho[arquivo_recente]:
                            arquivo_baixado = arquivo_recente
                            print(f"Download concluído: {os.path.basename(arquivo_baixado)}")
                            return arquivo_baixado
                    
                    ultimo_tamanho[arquivo_recente] = tamanho_atual
            
            # Aguarda 1 segundo antes de verificar novamente
            time.sleep(1)
        
        print(f"Tempo limite excedido ({timeout}s). Download não concluído.")
        return None
            
    
    def pegar_downloads(self):
        wait = WebDriverWait(self.driver, 120)
        
        try:
            # Clique em vários elementos conforme necessário
            elements = [
                '//*[@id="menu-cod-8"]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/ul/li[3]/a'
            ]
            
            for xpath in elements:
                element = wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
                self.driver.execute_script("arguments[0].click();", element)
                time.sleep(2)  # Adicione um tempo de espera se necessário
            
            # Código específico para clicar no botão de download com tratamento de exceção
            while True:
                try:
                    download_button = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_exportacoesGrid_baixarButton_0_btn_0"]')))
                    time.sleep(10)
                    self.driver.execute_script("arguments[0].click();", download_button)
                    time.sleep(10)
                    break  # Sai do loop se conseguir clicar no botão de download
                except TimeoutException:
                    # Verifica se o botão de alerta está presente
                    try:
                        alert_button = self.driver.find_element('xpath', '//*[@id="msgAlert"]')
                        if alert_button.is_displayed():
                            print("Alerta detectado. Recarregando a página...")
                            self.driver.refresh()  # Recarrega a página
                            time.sleep(5)  # Aguarda um tempo para a página recarregar
                            continue  # Volta para o início do loop
                    except NoSuchElementException:
                        pass  # Se o alerta não for encontrado, continua com a próxima tentativa
                except StaleElementReferenceException:
                    # Tenta buscar o elemento novamente se ocorrer StaleElementReferenceException
                    print("Elemento desatualizado detectado. Tentando buscar novamente...")
                    continue

                # Tentar clicar no botão de atualizar se o botão de download não estiver disponível
                try:
                    atualizar = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_atualizarButton_btn"]')))
                    self.driver.execute_script("arguments[0].click();", atualizar)
                    time.sleep(5)  # Adiciona um pequeno tempo de espera para o botão ser clicado
                except TimeoutException:
                    pass
        except StaleElementReferenceException:
            print("Elemento foi atualizado ou não está mais na página. Recarregando...")
            self.driver.refresh()  # Recarrega a página
            time.sleep(5)
            self.pegar_downloads()  # Tenta novamente
    
    def executar_fluxo_completo(self):
        """
        Executa o fluxo completo de extração de dados.
        
        Returns:
            bool: True se todo o fluxo foi bem-sucedido
        """
        try:
            # Criar diretório de downloads se não existir
            os.makedirs("downloads", exist_ok=True)
            
            # Realizar login
            if not self.entrar():
                print("Falha no login. Abortando operação.")
                return False
            
            # Buscar e baixar dados de vendas
            if not self.pegarVendas():
                print("Falha ao obter dados de vendas. Abortando operação.")
                return False
            
            print("Fluxo completo executado com sucesso!")
            return True
            
        except Exception as e:
            print(f"Erro no fluxo completo: {e}")
            return False
        finally:
            # Não fechar o navegador aqui, deixar isso para ser chamado explicitamente
            pass
    
    def fechar(self):
        """Fecha o navegador e limpa recursos."""
        try:
            if self.driver:
                self.driver.quit()
                self.driver = None
                print("Navegador fechado com sucesso.")
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")        

if __name__ == "__main__":
    rpa = PegarGoogle()
    while rpa.entrar():
        rpa.pegarVendas()
        rpa.fechar() 
        break
    banco = Banco()
    tratar = TratarDados()
    df = tratar.processar_arquivo_vendas()
    banco.inserirItensPedido(df)
    banco.fechar() 