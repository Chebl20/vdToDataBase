# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException,NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.chrome.service import Service 
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime, timedelta
import pandas as pd
import glob
import os
import numpy as np
from urllib.parse import quote
from sqlalchemy import create_engine, text
from sqlalchemy.types import String
from sqlalchemy.types import Integer
from sqlalchemy.types import Float
from sqlalchemy.types import DateTime
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException
import chromedriver_autoinstaller
from dotenv import load_dotenv
import logging
import io
from pandas.api.types import is_scalar
import psycopg2.extras
from seleniumbase import Driver
from psycopg2.extras import execute_values

# Configuração do sistema de logging

def setup_logger():
    # Cria pasta de logs se não existir
    log_dir = "logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Define formato da data para o nome do arquivo de log
    data_hora_atual = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = f"{log_dir}/execucao_{data_hora_atual}.log"
    
    # Configuração do logger
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger()

# Inicialização do logger global
logger = setup_logger()

# Carregando variáveis de ambiente do arquivo .env
load_dotenv()

ciclos_2024 = [
    {"ciclo":  1, "inicio": "26/12/2023", "fim": "21/01/2024"},
    {"ciclo":  2, "inicio": "22/01/2024", "fim": "11/02/2024"},
    {"ciclo":  3, "inicio": "12/02/2024", "fim": "03/03/2024"},
    {"ciclo":  4, "inicio": "04/03/2024", "fim": "24/03/2024"},
    {"ciclo":  5, "inicio": "25/03/2024", "fim": "14/04/2024"},
    {"ciclo":  6, "inicio": "15/04/2024", "fim": "12/05/2024"},
    {"ciclo":  7, "inicio": "13/05/2024", "fim": "26/05/2024"},
    {"ciclo":  8, "inicio": "27/05/2024", "fim": "12/06/2024"},
    {"ciclo":  9, "inicio": "13/06/2024", "fim": "30/06/2024"},
    {"ciclo": 10, "inicio": "01/07/2024", "fim": "22/07/2024"},
    {"ciclo": 11, "inicio": "23/07/2024", "fim": "11/08/2024"},
    {"ciclo": 12, "inicio": "12/08/2024", "fim": "01/09/2024"},
    {"ciclo": 13, "inicio": "02/09/2024", "fim": "21/09/2024"},
    {"ciclo": 14, "inicio": "22/09/2024", "fim": "13/10/2024"},
    {"ciclo": 15, "inicio": "14/10/2024", "fim": "03/11/2024"},
    {"ciclo": 16, "inicio": "04/11/2024", "fim": "01/12/2024"},
    {"ciclo": 17, "inicio": "02/12/2024", "fim": "25/12/2024"}, 
]

class TratarDados():
    def __init__(self):
        # Caminhos portáveis: primeiro busca na pasta 'downloads' do projeto, depois em 'Downloads' do usuário
        base_dir = os.path.dirname(os.path.abspath(__file__))
        projeto_downloads = os.path.join(base_dir, 'downloads')
        usuario_downloads = os.path.join(os.path.expanduser('~'), 'Downloads')

        padroes = [
            os.path.join(projeto_downloads, '*.xlsx'),
            os.path.join(usuario_downloads, '*.xlsx'),
        ]

        list_of_files = []
        for padrao in padroes:
            arquivos = glob.glob(padrao)
            if arquivos:
                list_of_files.extend(arquivos)

        if not list_of_files:
            raise FileNotFoundError("Nenhum arquivo XLSX encontrado nas pastas padrão ('downloads' do projeto ou 'Downloads' do usuário).")

        self.file = max(list_of_files, key=os.path.getctime)
        

    def processar_arquivo_itens_pedidos(self):
        try:
            logger.info(f"Iniciando processamento do arquivo: {self.file}")
            df = pd.read_excel(self.file, dtype=str)
            logger.info(f"Arquivo lido com sucesso. Total de linhas: {len(df)}")

            # Mapeamento de colunas para os novos dados
            mapeamento_colunas = {
                'Código Pedido': 'CodigoPedido',
                'Código Produto': 'CodigoProduto',
                'Produto': 'Produto',
                'Data captação pedido': 'DataCaptacao',
                'Ciclo captação pedido': 'CicloCaptacao',
                'Data faturamento': 'DataFaturamento',
                'Ciclo faturamento': 'CicloFaturamento',
                'Código Revendedor': 'Pessoa',
                'Revendedor': 'NomePessoa',
                'Papel': 'Papel',
                'Situação Fiscal': 'SituacaoFiscal',
                'Nota Fiscal': 'NotaFiscal',
                'Meio de captação': 'MeioCaptacao',
                'Código plano pagamento': 'CodPlanoPagamento',
                'Plano de pagamento': 'PlanoPagamento',
                'Tipo de Entrega': 'TipoEntrega',
                'Código usuário criação': 'CodUsuarioCriacao',
                'Usuário criação': 'UsuarioCriacao',
                'Código usuário finalização': 'CodUsuarioFinalizacao',
                'Usuário finalização': 'UsuarioFinalizacao',
                'Código CD': 'CodCD',
                'Canal de distribuição': 'CanalDistribuicao',
                'Qtde': 'QtdItens',
                'Total Tabela': 'ValorTabela',
                'Total Praticado': 'ValorPraticado',
                'Total Líquido': 'ValorLiquido'
            }

            # Renomear colunas existentes
            colunas_existentes = {k: v for k, v in mapeamento_colunas.items() if k in df.columns}
            logger.info(f"Colunas renomeadas: {list(colunas_existentes.values())}")
            df = df.rename(columns=colunas_existentes)
            
            
            colunas_str = ['CodigoProduto']
            for col in colunas_str:
                if col in df.columns:
                    df[col] = df[col].astype(str).str.replace('[.,]', '', regex=True).fillna('')

            # Converter colunas numéricas e de string
            colunas_str = ['CodigoPedido', 'Pessoa', 'CodUsuarioCriacao', 'CodUsuarioFinalizacao', 'CodCD', 'CodPlanoPagamento', 'CodigoProduto', 'NotaFiscal']
            for col in colunas_str:
                if col in df.columns:
                    df[col] = (
                        df[col]
                        .astype(str)
                        .str.replace('[.,]', '', regex=True)
                        .replace('nan', '')
                    )

            # Processar colunas de data
            if 'DataCaptacao' in df.columns:
                df['DataCaptacao'] = pd.to_datetime(df['DataCaptacao'], errors='coerce', dayfirst=True)
                df['DataCaptacao'] = df['DataCaptacao'].dt.date

            if 'DataFaturamento' in df.columns:
                df['DataFaturamento'] = pd.to_datetime(df['DataFaturamento'], errors='coerce', dayfirst=True)
                df['DataFaturamento'] = df['DataFaturamento'].dt.date

            # Processar valores monetários
            colunas_monetarias = ['ValorTabela', 'ValorPraticado', 'ValorLiquido']
            for col in colunas_monetarias:
                if col in df.columns:
                    df[col] = (
                        df[col]
                        .astype(str)
                        .str.replace('R\$ ', '', regex=True)  # Remove "R$ "
                        .str.replace('.', '', regex=False)
                        .str.replace(',', '.', regex=False)
                    )
                    df[col] = pd.to_numeric(df[col], errors='coerce', downcast='float')

            # Processar quantidade
            if 'QtdItens' in df.columns:
                df['QtdItens'] = pd.to_numeric(df['QtdItens'], errors='coerce').fillna(0).astype(int)

            # Manter apenas colunas mapeadas
            colunas_validas = [col for col in mapeamento_colunas.values() if col in df.columns]
            df = df[colunas_validas]

            # Substituir valores NaN por None
            df = df.where(pd.notna(df), None)
            
            df = df[(df['NotaFiscal'] != '0') ]

            logger.info("Processamento concluído com sucesso")
            return df

        except Exception as e:
            logger.error(f"Erro ao processar arquivo: {str(e)}")
            raise

class Banco():
    def __init__(self):
        self.engine = create_engine(os.getenv('DATABASE_URL')) 
        try:
            conn = self.engine.connect()
            result = conn.execute(text("SELECT 1"))
            if result.scalar() == 1:
                print("Conectado ao banco com sucesso!")
                self.criar_tabela()
            else:
                print("Erro ao conectar ao banco")
            conn.close()
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise
        
    def criar_tabela(self):
        try:
            with self.engine.connect() as conn:
                conn.execute(text("""
                    CREATE TABLE IF NOT EXISTS itens_pedidos (
                        CodigoPedido varchar(30) ,
                        CodigoProduto varchar(30) ,
                        Produto VARCHAR(200),
                        DataCaptacao DATE,
                        CicloCaptacao VARCHAR(10),
                        DataFaturamento DATE,
                        CicloFaturamento VARCHAR(10),
                        Pessoa VARCHAR(30),
                        NomePessoa VARCHAR(255),
                        Papel VARCHAR(20),
                        SituacaoFiscal VARCHAR(40),
                        NotaFiscal VARCHAR(30),
                        MeioCaptacao VARCHAR(30),
                        CodPlanoPagamento VARCHAR(30),
                        PlanoPagamento VARCHAR(255),
                        TipoEntrega VARCHAR(30),
                        CodUsuarioCriacao VARCHAR(30),
                        UsuarioCriacao VARCHAR(255),
                        CodUsuarioFinalizacao VARCHAR(30),
                        UsuarioFinalizacao VARCHAR(255),
                        CodCD VARCHAR(30),
                        CanalDistribuicao VARCHAR(255),
                        QtdItens INT,
                        ValorTabela DECIMAL(10, 2),
                        ValorPraticado DECIMAL(10, 2),
                        ValorLiquido DECIMAL(10, 2),
                        PRIMARY KEY (CodigoPedido, CodigoProduto),
                        FOREIGN KEY (CodigoPedido) REFERENCES pedidos(codigopedido) ON DELETE CASCADE
                    )
                """))
                conn.commit()
                print("Tabela 'itens_pedidos' criada/verificada com sucesso!")
        except Exception as e:
            print(f"Erro ao criar tabela: {e}")
            raise
        

    def inserirItensPedidos(self, itens_pedidos):
        try:
            # Normaliza para lista de dicts
            if hasattr(itens_pedidos, 'to_dict'):
                itens_pedidos = itens_pedidos.to_dict('records')

            colunas = [
                'CodigoPedido','CodigoProduto','Produto','DataCaptacao','CicloCaptacao',
                'DataFaturamento','CicloFaturamento','Pessoa','NomePessoa','Papel',
                'SituacaoFiscal','NotaFiscal','MeioCaptacao','CodPlanoPagamento','PlanoPagamento',
                'TipoEntrega','CodUsuarioCriacao','UsuarioCriacao','CodUsuarioFinalizacao',
                'UsuarioFinalizacao','CodCD','CanalDistribuicao','QtdItens',
                'ValorTabela','ValorPraticado','ValorLiquido'
            ]

            if not itens_pedidos:
                logger.info("Nenhum item recebido para processar.")
                return

            # Conexão RAW para usar execute_values
            conn = self.engine.raw_connection()
            cursor = conn.cursor()
            try:
                # 1) Garantimos que só inserimos itens cujos pedidos existem
                cursor.execute("SELECT DISTINCT codigopedido FROM pedidos")
                pedidos_existentes = {row[0] for row in cursor.fetchall()}
                batch = [i for i in itens_pedidos if i.get('CodigoPedido') in pedidos_existentes]
                if not batch:
                    logger.warning("Nenhum item com pedido existente encontrado.")
                    conn.rollback()
                    return

                values = [tuple(i.get(c) for c in colunas) for i in batch]

                # 2) Tabela temporária para este batch
                cursor.execute("""
                    CREATE TEMP TABLE tmp_itens_pedidos (
                        CodigoPedido varchar(30),
                        CodigoProduto varchar(30),
                        Produto VARCHAR(200),
                        DataCaptacao DATE,
                        CicloCaptacao VARCHAR(10),
                        DataFaturamento DATE,
                        CicloFaturamento VARCHAR(10),
                        Pessoa VARCHAR(30),
                        NomePessoa VARCHAR(255),
                        Papel VARCHAR(20),
                        SituacaoFiscal VARCHAR(40),
                        NotaFiscal VARCHAR(30),
                        MeioCaptacao VARCHAR(30),
                        CodPlanoPagamento VARCHAR(30),
                        PlanoPagamento VARCHAR(255),
                        TipoEntrega VARCHAR(30),
                        CodUsuarioCriacao VARCHAR(30),
                        UsuarioCriacao VARCHAR(255),
                        CodUsuarioFinalizacao VARCHAR(30),
                        UsuarioFinalizacao VARCHAR(255),
                        CodCD VARCHAR(30),
                        CanalDistribuicao VARCHAR(255),
                        QtdItens INT,
                        ValorTabela DECIMAL(10, 2),
                        ValorPraticado DECIMAL(10, 2),
                        ValorLiquido DECIMAL(10, 2)
                    ) ON COMMIT DROP
                """)

                # 3) Bulk load no staging
                execute_values(
                    cursor,
                    f"INSERT INTO tmp_itens_pedidos ({', '.join(colunas)}) VALUES %s",
                    values,
                    page_size=1000
                )

                # 4) Apagar itens cortados (somente dos pedidos presentes no batch)
                #    Remove toda linha da tabela principal cujo (Pedido,Produto) não está no staging
                cursor.execute("""
                    DELETE FROM itens_pedidos ip
                    USING (
                        SELECT DISTINCT CodigoPedido FROM tmp_itens_pedidos
                    ) p
                    WHERE ip.CodigoPedido = p.CodigoPedido
                    AND NOT EXISTS (
                        SELECT 1
                        FROM tmp_itens_pedidos t
                        WHERE t.CodigoPedido = ip.CodigoPedido
                            AND t.CodigoProduto = ip.CodigoProduto
                    )
                """)

                # 5) UPSERT dos válidos
                set_clause = ', '.join(
                    f"{c}=EXCLUDED.{c}" for c in colunas if c not in ('CodigoPedido','CodigoProduto')
                )
                cursor.execute(f"""
                    INSERT INTO itens_pedidos ({', '.join(colunas)})
                    SELECT {', '.join(colunas)} FROM tmp_itens_pedidos
                    ON CONFLICT (CodigoPedido, CodigoProduto)
                    DO UPDATE SET {set_clause}
                """)

                conn.commit()
                logger.info(f"Sincronização concluída: {len(batch)} itens válidos upsertados; itens cortados removidos.")
            except Exception as e:
                conn.rollback()
                logger.error(f"Erro na sincronização de itens: {e}")
                raise
            finally:
                cursor.close()
                conn.close()

        except Exception as e:
            logger.error(f"Erro ao inserir/atualizar itens de pedidos: {str(e)}")
            raise

    
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.engine:
                self.engine.dispose()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
    
    def consulta(self):
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT DISTINCT ciclocaptacao FROM pedidos"))
                return result
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise


class PegarGoogle():
    
    def __init__(self):
        logger.info("Inicializando PegarGoogle e o driver do Chrome...")
        self.driver = None
        self.wait = None
        self.data_formatada = None
        self.ciclo_1 = None
        self.ciclo_2 = None
        
        # Diretório de download personalizado
        base_dir = os.path.dirname(os.path.abspath(__file__))
        download_dir = os.path.join(base_dir, 'downloads')
        self.download_dir = download_dir
        
        # Garantir que o diretório de download existe
        os.makedirs(download_dir, exist_ok=True)

        try:
            logger.info("Configurando opções do Chrome")

            logger.info("Iniciando Chrome")
            
            driver = Driver(
                browser="chrome",
                uc=True,  # Usa undetected-chromedriver para evitar bloqueios de bot
                incognito=False,  # Ou use guest_mode=True se não quiser salvar nada
                locale_code="pt-BR",
                guest_mode=True,   
                disable_gpu=True, # Cria perfil novo, sem conta
                headless=True,
                chromium_arg="--no-first-run,"
                    "--no-default-browser-check,"
                    "--disable-infobars,"
                    "--disable-popup-blocking,"
                    "--disable-extensions,"
                    "--disable-features=ChromeWhatsNewUI,"
                    "--disable-sync,"
                    "--disable-signin-promo,"
                    "--disable-background-networking,"
                    "--disable-features=SignInProfileCreation,ChromeSignin,"
            )
    
            driver.execute_cdp_cmd('Page.setDownloadBehavior', {
                'behavior': 'allow',
                'downloadPath': download_dir
            })

            self.driver = driver
            
            # Configurar comportamento de download via CDP
            self.driver.execute_cdp_cmd("Page.setDownloadBehavior", {
                "behavior": "allow",
                "downloadPath": download_dir
            })

            # Configurar wait com timeout mais longo (120s)
            logger.info("Configurando WebDriverWait com timeout de 120 segundos")
            self.wait = WebDriverWait(self.driver, 120)
            self.vars = {}
            
            # Maximizar a janela
            self.driver.maximize_window()
            logger.info("Setup do Selenium concluído")
            
            # Inicializar variáveis de ciclo
            self.ciclo = None

        except Exception as e:
            logger.error(f"Erro ao inicializar o Chrome: {e}")
            if isinstance(e, WebDriverException):
                logger.error("Erro específico do WebDriver. Verifique se o Chrome está instalado corretamente.")
            self.fechar()
            raise
            
    def _esperar_e_clicar(self, by, valor, timeout=30):
        """Função auxiliar para esperar e clicar em elementos com retry"""
        logger.info(f"Tentando clicar no elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de clicar no elemento: {valor}")
                elemento = self.wait.until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].click();", elemento)
                logger.info(f"Clique bem-sucedido no elemento: {valor}")
                return True
            except Exception as e:
                if tentativa == 2:  # última tentativa 
                    logger.error(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def _esperar_elemento(self, by, valor, timeout=30):
        """Função auxiliar para esperar elementos com retry"""
        logger.info(f"Aguardando presença do elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de localizar o elemento: {valor}")
                elemento = self.wait.until(
                    EC.presence_of_element_located((by, valor))
                )
                logger.info(f"Elemento localizado com sucesso: {valor}")
                return elemento
            except Exception as e:
                if tentativa == 2:  # última tentativa
                    logger.error(f"Erro ao esperar elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def entrar(self):
        try:
            self.driver.get("https://sgi.e-boticario.com.br/Paginas/Acesso/Entrar.aspx?ReturnUrl=%2f")
                
            usuario = 'chebljose@gmail.com'
            senha = 'Oliveira26@2004'
            self.driver.click(r'#btnLoginExterno')
            print("entrou no site")
            
            time.sleep(3)
            self.driver.click(r'#GoogleExchange')
            print("entrou no google")
            
            self.driver.type("#identifierId", usuario)
            self.driver.click("#identifierNext > div > button")
            print("Passando o usuario")

            self.driver.type("#password > div.aCsJod.oJeWuf > div > div.Xb9hP > input", senha)
            self.driver.click("#passwordNext > div > button")
            print("Passando a senha")
            time.sleep(10)
            return True
            
        except ValueError as e:
            logger.error(f"Erro de validação ao fazer login: {str(e)}")
            logger.error("Verifique se as variáveis de ambiente vdUsername e vdPassword estão configuradas")
            return False
        except Exception as e:
            logger.error(f"Erro ao fazer login: {str(e)}", exc_info=True)
            return False
            
    def pegarItensVendas(self):
        try:
            logger.info("Iniciando processo de busca e exportação de pedidos")
            ciclo = 1
            
            # Navegação inicial
            logger.info("Navegando para o menu de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="menu-cod-1"]/a')
            logger.info("Expandindo submenu")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="submenu-cod-1"]/div/div[1]/ul/li[5]/a')
            logger.info("Acessando consulta de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="submenu-cod-1"]/div/div[1]/ul/li[5]/ul/li[2]/a')
            
            # Configurar filtros
            logger.info("Abrindo seletor de situações comerciais")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_ddlSituacaoComercial_Tb1"]')
            
            # Marcar opções de tipos de produto
            logger.info("Marcando todas as situações comerciais")
            situacoes_comerciais = [1,4,6,7,8]
            for situacao in situacoes_comerciais:
                xpath = f'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_ddlSituacaoComercial_D0"]/div/ul/li[{situacao}]/a/label'
                self._esperar_e_clicar(By.XPATH, xpath)
            
            logger.info("Limpando campo de data inicial")
            data_inicio = self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_txtDataInicialCaptacao_Tb1"]')
            data_inicio.clear()
            
            data_fim = self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_txtDataFinalCaptacao_Tb1"]')
            data_fim.clear()
            
            # Configurando período de busca
            hoje = datetime.today()
            inicio = hoje - timedelta(days=1)
            fim = hoje
            inicio_formatado = inicio.strftime('%d%m%Y')
            fim_formatado = fim.strftime('%d%m%Y')
            
            logger.info(f"Configurando período de busca: {inicio.strftime('%d/%m/%Y')} a {fim.strftime('%d/%m/%Y')}")
            
            logger.info("Preenchendo data inicial")
            self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_txtDataInicialCaptacao_Tb1"]').send_keys(inicio_formatado)
            
            logger.info("Preenchendo data final")
            self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_txtDataFinalCaptacao_Tb1"]').send_keys(fim_formatado)
            
            logger.info("Aguardando 3 segundos para garantir que os filtros foram aplicados")
            time.sleep(3)

            # Buscar e exportar
            logger.info("Iniciando busca de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_btnBuscar_B1"]')
            
            logger.info("Clicando no botão de exportar")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ctlRelatorioItensPorVendedor_btnExportar_B1"]')
            
            logger.info("Selecionando opção de exportação")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="tab-01"]/div[3]/div/div[2]/div/div[1]/span/label')
            
            logger.info("Iniciando processo de download")
            self.pegar_downloads()
            
            logger.info("Fechando janelas secundárias")
            self.fecharJanela()
            
            logger.info("Processo de busca e exportação de pedidos concluído com sucesso")
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao pegar pedidos: {e}", exc_info=True)
            raise
            
    def fecharJanela(self):
        logger.info("Tentando fechar janela secundária")
        try:
            logger.debug("Verificando número de janelas abertas")
            if WebDriverWait(self.driver, 10).until(EC.number_of_windows_to_be(2)):
                janelas = self.driver.window_handles
                logger.info(f"Detectadas {len(janelas)} janelas. Alternando para a janela secundária")
                self.driver.switch_to.window(janelas[1])
                logger.info("Fechando janela secundária")
                self.driver.close()
                logger.info("Voltando para a janela principal")
                self.driver.switch_to.window(janelas[0])
                logger.info("Janela secundária fechada com sucesso")
        except TimeoutException:
            logger.warning("Não foi detectada uma segunda janela para fechar")
        except Exception as e:
            logger.error(f"Erro ao fechar janela: {e}", exc_info=True)
            
    def pegar_downloads(self):
        wait = WebDriverWait(self.driver, 120)
        
        try:
            # Clique em vários elementos conforme necessário
            elements = [
                '//*[@id="agendamentoExportacao_exportarPanel"]/div/div/div[2]/div[1]/div/div/div[2]/ul/li[2]/a',
                '//*[@id="agendamentoExportacao_colunasTab"]/div[1]/div/div/label',
                '//*[@id="agendamentoExportacao_divIncluirDadosPessoais"]/label',
                '//*[@id="popupOkButton"]',
                '//*[@id="agendamentoExportacao_okButton_B1"]',
                '//*[@id="popupOkButton"]',
                '//*[@id="menu-cod-8"]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/ul/li[3]/a'
            ]
            
            
            for xpath in elements:
                element = wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
                self.driver.execute_script("arguments[0].click();", element)
                time.sleep(2)  # Adicione um tempo de espera se necessário
            
            # Código específico para clicar no botão de download com tratamento de exceção
            while True:
                try:
                    download_button = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_exportacoesGrid_baixarButton_0_btn_0"]')))
                    time.sleep(10)
                    self.driver.execute_script("arguments[0].click();", download_button)
                    time.sleep(10)
                    break  # Sai do loop se conseguir clicar no botão de download
                except TimeoutException:
                    # Verifica se o botão de alerta está presente
                    try:
                        alert_button = self.driver.find_element('xpath', '//*[@id="msgAlert"]')
                        if alert_button.is_displayed():
                            logger.info("Alerta detectado. Recarregando a página...")
                            self.driver.refresh()  # Recarrega a página
                            time.sleep(5)  # Aguarda um tempo para a página recarregar
                            continue  # Volta para o início do loop
                    except NoSuchElementException:
                        pass  # Se o alerta não for encontrado, continua com a próxima tentativa
                except StaleElementReferenceException:
                    # Tenta buscar o elemento novamente se ocorrer StaleElementReferenceException
                    logger.info("Elemento desatualizado detectado. Tentando buscar novamente...")
                    continue

                # Tentar clicar no botão de atualizar se o botão de download não estiver disponível
                try:
                    atualizar = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_atualizarButton_btn"]')))
                    self.driver.execute_script("arguments[0].click();", atualizar)
                    time.sleep(5)  # Adiciona um pequeno tempo de espera para o botão ser clicado
                except TimeoutException:
                    pass
        except StaleElementReferenceException:
            logger.info("Elemento foi atualizado ou não está mais na página. Recarregando...")
            self.driver.refresh()  # Recarrega a página
            time.sleep(5)
            self.pegar_downloads()  # Tenta novamente
            
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.driver:
                self.driver.quit()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
            
if __name__ == "__main__":
    
    logger.info("Iniciando execução principal do script Pedidos.py")
    
    rpa = PegarGoogle()
    while rpa.entrar():
        logger.info("Chamando método pegarItensVendas()")
        if rpa.pegarItensVendas():
            break
    
    logger.info("Execução principal finalizada")
    banco = Banco()
    banco.criar_tabela()
    banco.fechar()
    
    tratar = TratarDados()
    df = tratar.processar_arquivo_itens_pedidos()
    banco.inserirItensPedidos(df)

    banco.fechar()
    rpa.fechar()
    
