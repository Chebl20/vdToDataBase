# Generated by Selenium IDE
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException,NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service 
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime, timedelta
import pandas as pd
import glob
import os
import numpy as np
from urllib.parse import quote
from sqlalchemy import create_engine, text
from sqlalchemy.types import String, Integer, Float, DateTime
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException
import chromedriver_autoinstaller
from dotenv import load_dotenv
import io
import csv
from pandas.api.types import is_scalar
import psycopg2.extras
import openpyxl 
import glob
import os
import pandas as pd
from typing import Dict, List, Optional, Tuple, Union

# Configuração de logging aprimorada
from logger_config import get_logger, logger as root_logger
from logging_utils import log_execution_time, LogContext, log_dataframe_info, log_exception



# Configuração do logger para este módulo
logger = get_logger(__name__)

# Carregando variáveis de ambiente do arquivo .env
load_dotenv()

ciclos_2025 = [
    {"ciclo": 1, "inicio": "26/12/2024", "fim": "19/01/2025"},
    {"ciclo": 2, "inicio": "20/01/2025", "fim": "09/02/2025"},
    {"ciclo": 3, "inicio": "10/02/2025", "fim": "02/03/2025"},
    {"ciclo": 4, "inicio": "03/03/2025", "fim": "23/03/2025"},
    {"ciclo": 5, "inicio": "24/03/2025", "fim": "13/04/2025"},
    {"ciclo": 6, "inicio": "14/04/2025", "fim": "11/05/2025"},
    {"ciclo": 7, "inicio": "12/05/2025", "fim": "25/05/2025"},
    {"ciclo": 8, "inicio": "26/05/2025", "fim": "12/06/2025"},
    {"ciclo": 9, "inicio": "13/06/2025", "fim": "29/06/2025"},
    {"ciclo": 10, "inicio": "30/06/2025", "fim": "20/07/2025"},
    {"ciclo": 11, "inicio": "21/07/2025", "fim": "10/08/2025"},
    {"ciclo": 12, "inicio": "11/08/2025", "fim": "31/08/2025"},
    {"ciclo": 13, "inicio": "01/09/2025", "fim": "21/09/2025"},
    {"ciclo": 14, "inicio": "22/09/2025", "fim": "12/10/2025"},
    {"ciclo": 15, "inicio": "13/10/2025", "fim": "02/11/2025"},
    {"ciclo": 16, "inicio": "03/11/2025", "fim": "30/11/2025"},
    {"ciclo": 17, "inicio": "01/12/2025", "fim": "25/12/2025"},
]

class TratarDados:
    """Classe para tratamento de dados de vendas a partir de arquivos XLS, XLSX, CSV ou TXT."""
    
    # Mapeamento de colunas esperadas e seus limites
    COLUNAS_ESPERADAS = {
        'Código Produto': ('CodigoProduto', 10),
        'Nome Produto': ('NomeProduto', 50),
        'Cód Est Pai': ('CodEstPai', 20),
        'Estrutura Pai': ('EstruturaPai', 20),
        'CodEstCom': ('CodEstCom', 20),
        'NomeEstCom': ('NomeEstCom', 20),
        'Responsável Est Com': ('ResponsavelEstCom', 20),
        'Quantidade': ('Quantidade', None),  # Numérico, sem limite de string
        'Código Pedido': ('CodigoPedido', 20),
        'Código Pessoa': ('CodigoPessoa', 20),
        'Nome Pessoa': ('NomePessoa', 50),
        'Data Pedido': ('DataPedido', None),  # Data, sem limite de string
        'Ciclo': ('Ciclo', 10),
        'SubCiclo': ('SubCiclo', 10),
        'Situação pedido': ('SituacaoPedido', 30),
        'Nome Modelo Comercial': ('NomeModeloComercial', 1000)
    }
    
    def __init__(self, caminho_padrao: Optional[str] = None):
        """
        Inicializa a classe com o caminho padrão ou usa um caminho portátil baseado no projeto.
        
        Args:
            caminho_padrao: Caminho opcional para buscar os arquivos. Se None, usa o padrão na pasta 'downloads' do projeto.
        """
        base_dir = os.path.dirname(os.path.abspath(__file__))
        caminho = caminho_padrao or os.path.join(base_dir, 'downloads', 'BuscarPedidosItensAnalitico_*.xls')
        self._encontrar_arquivo_mais_recente(caminho)
    
    def _encontrar_arquivo_mais_recente(self, caminho: str):
        """Encontra o arquivo mais recente no caminho especificado."""
        list_of_files = glob.glob(caminho)
        if not list_of_files:
            raise FileNotFoundError(f"Nenhum arquivo 'BuscarPedidosItensAnalitico_*.xls' encontrado em {caminho}.")
        self.file = max(list_of_files, key=os.path.getctime)
        logger.info(f"Arquivo selecionado para processamento: {self.file}")
    
    @log_execution_time
    def processar_arquivo_vendas(self) -> pd.DataFrame:
        """
        Processa o arquivo de vendas e retorna um DataFrame tratado.
        
        Returns:
            pd.DataFrame: DataFrame com os dados processados
            
        Raises:
            Exception: Se ocorrer um erro durante o processamento
        """
        with LogContext("Processamento de arquivo de vendas", arquivo=self.file):
            try:
                # Leitura do arquivo
                df = self._ler_arquivo()
                log_dataframe_info(df, "Dados brutos")
                
                # Validação básica
                self._validar_estrutura_arquivo(df)
                
                # Renomear colunas
                df = self._renomear_colunas(df)
                logger.info(f"Colunas após renomeação: {list(df.columns)}")
                
                # Processamento de dados
                df = self._processar_datas(df)
                df = self._processar_numericos(df)
                df = self._truncar_colunas(df)
                df = self._remover_pontos_codigos(df)
                
                # Validação final
                self._validar_dados(df)
                
                # Log resumo do processamento
                logger.info(f"Processamento concluído. Total de registros: {len(df)}")
                log_dataframe_info(df, "Dados processados")
                
                return df
                
            except Exception as e:
                log_exception("Falha ao processar arquivo de vendas")
                raise
    
    def _ler_arquivo(self) -> pd.DataFrame:
        """Lê o arquivo de acordo com seu formato."""
        extensao = os.path.splitext(self.file)[-1].lower()
        
        if extensao in ['.xls', '.xlsx']:
            logger.info("Lendo arquivo Excel")
            return pd.read_excel(self.file, dtype=str)
        
        elif extensao in ['.csv', '.txt']:
            logger.info("Lendo arquivo texto")
            self._validar_arquivo_texto()
            return pd.read_csv(
                self.file, 
                sep='|', 
                quotechar='"', 
                encoding='utf-8', 
                engine='python', 
                on_bad_lines='warn', 
                dtype=str
            )
        
        raise ValueError(f"Formato de arquivo não suportado: {extensao}")
    
    def _validar_arquivo_texto(self) -> None:
        """
        Valida a estrutura do arquivo texto antes da leitura.
        
        Raises:
            ValueError: Se o arquivo contiver muitas linhas inválidas
        """
        linhas_invalidas = []
        total_linhas = 0
        
        with LogContext("Validação de arquivo texto", arquivo=self.file):
            try:
                with open(self.file, 'r', encoding='utf-8') as f:
                    for i, line in enumerate(f):
                        total_linhas += 1
                        parts = line.strip().split('|')
                        if len(parts) != 17:
                            linhas_invalidas.append((i + 1, len(parts), line.strip()))
                
                if linhas_invalidas:
                    percentual_invalido = (len(linhas_invalidas) / total_linhas) * 100
                    
                    if percentual_invalido > 10:  # Mais de 10% de linhas inválidas
                        erro_msg = (
                            f"Muitas linhas inválidas encontradas: {len(linhas_invalidas)} "
                            f"de {total_linhas} ({percentual_invalido:.2f}%)"
                        )
                        logger.error(erro_msg)
                        raise ValueError(erro_msg)
                    
                    # Log detalhado das primeiras 5 linhas inválidas
                    logger.warning(
                        f"{len(linhas_invalidas)} linhas inválidas encontradas "
                        f"({percentual_invalido:.2f}% do total)"
                    )
                    
                    for i, (linha_num, num_cols, conteudo) in enumerate(linhas_invalidas[:5], 1):
                        logger.warning(
                            f"Linha inválida #{i}: "
                            f"Número: {linha_num}, "
                            f"Colunas: {num_cols}, "
                            f"Início: {conteudo[:100]}..."
                        )
                    
                    if len(linhas_invalidas) > 5:
                        logger.warning(
                            f"... e mais {len(linhas_invalidas) - 5} linhas com problemas "
                            f"(total: {len(linhas_invalidas)} linhas inválidas)"
                        )
                else:
                    logger.info("Nenhuma linha inválida encontrada no arquivo.")
                    
            except Exception as e:
                log_exception("Erro durante a validação do arquivo texto")
                raise
    
    def _validar_estrutura_arquivo(self, df: pd.DataFrame) -> None:
        """
        Valida a estrutura básica do DataFrame.
        
        Args:
            df: DataFrame a ser validado
            
        Raises:
            ValueError: Se o DataFrame estiver vazio ou faltarem colunas obrigatórias
        """
        with LogContext("Validação de estrutura do arquivo"):
            if df.empty:
                erro_msg = "O arquivo está vazio. Nenhum dado para processar."
                logger.error(erro_msg)
                raise ValueError(erro_msg)
                
            colunas_obrigatorias = set(self.COLUNAS_ESPERADAS.keys())
            colunas_faltantes = colunas_obrigatorias - set(df.columns)
            
            if colunas_faltantes:
                erro_msg = f"Colunas obrigatórias não encontradas: {', '.join(colunas_faltantes)}"
                logger.error(erro_msg)
                logger.error(f"Colunas esperadas: {sorted(colunas_obrigatorias)}")
                logger.error(f"Colunas encontradas: {sorted(df.columns)}")
                raise ValueError(erro_msg)
                
            logger.info(
                f"Estrutura do arquivo validada com sucesso. "
                f"Colunas encontradas: {len(df.columns)}, "
                f"Linhas: {len(df)}"
            )
            
            # Log de amostra das primeiras linhas para validação
            logger.debug("Amostra das primeiras linhas do DataFrame:")
            for i, (_, row) in enumerate(df.head(2).iterrows(), 1):
                logger.debug(f"Linha {i} - {row.to_dict()}")
    
    def _renomear_colunas(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Renomeia as colunas do DataFrame conforme o mapeamento.
        
        Args:
            df: DataFrame com as colunas originais
            
        Returns:
            DataFrame com as colunas renomeadas
        """
        with LogContext("Renomeando colunas"):
            mapeamento = {k: v[0] for k, v in self.COLUNAS_ESPERADAS.items() if k in df.columns}
            colunas_antes = set(df.columns)
            
            # Log das colunas que serão renomeadas
            if mapeamento:
                logger.debug("Mapeamento de colunas a serem renomeadas:")
                for antigo, novo in mapeamento.items():
                    logger.debug(f"  {antigo} -> {novo}")
            
            # Aplica o renomeamento
            df_renomeado = df.rename(columns=mapeamento)
            
            # Verifica se alguma coluna não foi mapeada
            colunas_nao_mapeadas = colunas_antes - set(mapeamento.keys())
            if colunas_nao_mapeadas:
                logger.warning(
                    f"{len(colunas_nao_mapeadas)} colunas não foram mapeadas: "
                    f"{', '.join(sorted(colunas_nao_mapeadas))}"
                )
            
            logger.info(f"{len(mapeamento)} colunas renomeadas com sucesso")
            return df_renomeado
    
    def _processar_datas(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Converte colunas de data para o formato datetime.
        
        Args:
            df: DataFrame com as colunas de data
            
        Returns:
            DataFrame com as colunas de data convertidas
        """
        with LogContext("Processando datas"):
            colunas_data = ['Data Pedido']
            df_processado = df.copy()
            
            for coluna in colunas_data:
                if coluna in df_processado.columns:
                    valores_antes = len(df_processado[coluna])
                    
                    # Converte para datetime
                    df_processado[coluna] = pd.to_datetime(
                        df_processado[coluna], 
                        errors='coerce',
                        dayfirst=True  # Assume formato DD/MM/YYYY
                    )
                    
                    # Conta valores nulos após conversão
                    nulos_apos = df_processado[coluna].isna().sum()
                    
                    # Log de estatísticas
                    logger.info(
                        f"Coluna '{coluna}': "
                        f"{valores_antes - nulos_apos}/{valores_antes} "
                        f"({(valores_antes - nulos_apos)/valores_antes:.1%}) "
                        "datas convertidas com sucesso"
                    )
                    
                    if nulos_apos > 0:
                        logger.warning(
                            f"{nulos_apos} valores não puderam ser convertidos para data "
                            f"na coluna '{coluna}'"
                        )
                        
                        # Log de amostra de valores problemáticos
                        valores_problematicos = df.loc[
                            df_processado[coluna].isna() & df[coluna].notna(), 
                            coluna
                        ].unique()[:5]  # Apenas os 5 primeiros valores únicos
                        
                        if len(valores_problematicos) > 0:
                            logger.debug(
                                f"Valores problemáticos em '{coluna}': "
                                f"{', '.join(map(str, valores_problematicos))}"
                                + ("..." if len(valores_problematicos) == 5 else "")
                            )
            
            return df_processado
    
    def _processar_numericos(self, df: pd.DataFrame) -> pd.DataFrame:
        """Processa colunas numéricas."""
        with LogContext("Processando números"):
            if 'Quantidade' in df.columns:
                df['Quantidade'] = (
                    pd.to_numeric(df['Quantidade'], errors='coerce')
                    .fillna(0)
                    .astype(int)
                )
                logger.info("Coluna 'Quantidade' processada com sucesso")
            return df
    
    def _truncar_colunas(self, df: pd.DataFrame) -> pd.DataFrame:
        """Trunca as colunas de texto conforme os limites definidos."""
        for col in df.columns:
            if col in [novo[0] for novo in self.COLUNAS_ESPERADAS.values() if novo[1]]:
                limite = next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)
                df[col] = (
                    df[col]
                    .fillna('')
                    .apply(lambda x: str(x).strip()[:limite] if x is not None else '')
                    .replace('', None)
                )
        return df
    
    def _remover_pontos_codigos(self, df: pd.DataFrame) -> pd.DataFrame:
        """Remove pontos de códigos e aplica truncamento."""
        for col in ['CodigoPedido', 'CodigoProduto', 'CodigoPessoa']:
            if col in df.columns:
                df[col] = (
                    df[col]
                    .fillna('')
                    .apply(lambda x: x.replace('.', '')[:next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)] if x else '')
                    .replace('', None)
                )
        return df
    
    def _validar_dados(self, df: pd.DataFrame) -> None:
        """Realiza validações finais nos dados."""
        # Verificar valores longos
        for col in df.columns:
            if col in [novo[0] for novo in self.COLUNAS_ESPERADAS.values() if novo[1]]:
                limite = next(novo[1] for novo in self.COLUNAS_ESPERADAS.values() if novo[0] == col)
                valores_longos = df[col].dropna().apply(lambda x: len(str(x)) > limite)
                if valores_longos.any():
                    logger.warning(f"Coluna {col} tem {valores_longos.sum()} valores excedendo o limite de {limite} caracteres")
        
        # Verificar valores nulos em colunas importantes
        for col in ['CodigoProduto', 'CodigoPedido', 'Quantidade']:
            if col in df.columns and df[col].isna().any():
                logger.warning(f"Coluna {col} contém valores nulos")

class Banco:
    def __init__(self):
        self.engine = create_engine(os.getenv('dbUrlConnect'))
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                if result.scalar() == 1:
                    logger.info("Conectado ao banco com sucesso!")
                    self.criar_tabela()
                else:
                    logger.error("Erro ao conectar ao banco.")
        except Exception as e:
            logger.error(f"Erro ao conectar ao banco: {e}")
            raise
    
    def criar_tabela(self):
        try:
            with self.engine.begin() as conn:
                conn.execute(text("""
                    CREATE TABLE IF NOT EXISTS itens_pedido (
                        id SERIAL PRIMARY KEY,
                        codigo_produto VARCHAR(10),
                        nome_produto TEXT,
                        cod_est_pai VARCHAR(10),
                        estrutura_pai TEXT,
                        cod_est_com VARCHAR(10),
                        nome_est_com TEXT,
                        responsavel_est_com VARCHAR(20),
                        quantidade INTEGER,
                        codigopedido VARCHAR(20),
                        codigo_pessoa VARCHAR(20),
                        nome_pessoa TEXT,
                        data_pedido TIMESTAMP,
                        ciclo VARCHAR(10),
                        subciclo VARCHAR(10),
                        situacao_pedido VARCHAR(20),
                        nome_modelo_comercial TEXT,
                        UNIQUE (codigopedido, codigo_produto),
                        FOREIGN KEY (codigopedido) REFERENCES pedidos(CodigoPedido)
                    );
                """))
                logger.info("Tabela 'itens_pedido' criada/verificada com sucesso!")
        except Exception as e:
            logger.error(f"Erro ao criar tabela: {e}")
            raise
    
    def inserirItensPedido(self, itens):
        try:
            itens.to_excel('itens_pedido_ant_ren.xlsx', index=False)
            
            itens = itens.rename(columns={
                "CodigoPedido": "codigopedido",
                "CodigoProduto": "codigo_produto",
                "NomeProduto": "nome_produto",
                "CodEstPai": "cod_est_pai",
                "EstruturaPai": "estrutura_pai",
                "CodEstCom": "cod_est_com",
                "NomeEstCom": "nome_est_com",
                "ResponsavelEstCom": "responsavel_est_com",
                "Quantidade": "quantidade",
                "CodigoPessoa": "codigo_pessoa",
                "NomePessoa": "nome_pessoa",
                "DataPedido": "data_pedido",
                "Ciclo": "ciclo",
                "SubCiclo": "subciclo",
                "SituacaoPedido": "situacao_pedido",
                "NomeModeloComercial": "nome_modelo_comercial"
            })
            
            if hasattr(itens, 'to_dict'):
                itens = itens.to_dict('records')
                
            colunas = [
                "codigopedido", "codigo_produto", "nome_produto", "cod_est_pai", "estrutura_pai",
                "cod_est_com", "nome_est_com", "responsavel_est_com", "quantidade", "codigo_pessoa",
                    "nome_pessoa", "data_pedido", "ciclo", "subciclo", "situacao_pedido", "nome_modelo_comercial"
                ]

            values = [tuple(item.get(col, None) for col in colunas) for item in itens]

            insert_query = f"""
                INSERT INTO itens_pedido ({', '.join(colunas)})
                VALUES ({', '.join(['%s'] * len(colunas))})
                ON CONFLICT (codigopedido, codigo_produto)
                    DO UPDATE SET
                        {', '.join([f"{col} = EXCLUDED.{col}" for col in colunas if col not in ['codigopedido', 'codigo_produto']])}
                """

            conn = self.engine.raw_connection()
            cursor = conn.cursor()
            try:
                psycopg2.extras.execute_batch(cursor, insert_query, values)
                conn.commit()
                logger.info("Inserção/atualização de itens de pedido concluída com sucesso.")
            except Exception as e:
                conn.rollback()
                logger.error(f"Erro ao inserir/atualizar itens de pedido: {e}")
                raise
            finally:
                cursor.close()
                conn.close()

        except Exception as e:
            logger.error(f"Erro ao preparar dados dos itens de pedido: {e}")
            raise

    def fechar(self):
        """Método para fechar a conexão com o banco"""
        try:
            if self.engine:
                self.engine.dispose()
                logger.info("Conexão com o banco encerrada.")
        except Exception as e:
            logger.error(f"Erro ao fechar a conexão com o banco: {e}")

class PegarGoogle:
    """
    Classe para automatizar interações com o sistema SGI e-Boticario,
    realizando login, extração de dados de vendas e download de relatórios.
    """
    
    def __init__(self):
        """Inicializa o driver do Chrome com download automático da versão correta."""
        logger.info("Inicializando PegarGoogle e o driver do Chrome...")
        self.driver = None
        self.wait = None
        self.data_formatada = None
        self.ciclo_1 = None
        self.ciclo_2 = None

        try:
            # Configuração das opções do Chrome
            options = Options()
            options.add_argument('--start-maximized')
            options.add_argument('--disable-extensions')
            options.add_argument('--disable-gpu')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--headless')
            options.add_experimental_option('excludeSwitches', ['enable-logging'])
            options.add_experimental_option('detach', True)

            # Configuração para downloads automáticos
            prefs = {
                "download.default_directory": os.path.join(os.getcwd(), "downloads"),
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": True
            }
            options.add_experimental_option("prefs", prefs)

            logger.info("Iniciando Chrome com driver automático")
            self.driver = webdriver.Chrome(
                service=Service(ChromeDriverManager().install()),
                options=options
            )
            self.wait = WebDriverWait(self.driver, 30)

            self.driver.maximize_window()
            self._configurar_data_e_ciclos()

        except Exception as e:
            logger.error(f"Erro ao inicializar o Chrome: {e}")
            if isinstance(e, WebDriverException):
                logger.error("Erro específico do WebDriver. Verifique se o Chrome está instalado corretamente.")
            self.fechar()
            raise
    
    def _configurar_data_e_ciclos(self):
        """Configura a data de ontem e identifica os ciclos correspondentes."""
        data_de_ontem = self.diaOntem()
        self.data_formatada = data_de_ontem.strftime('%d%m%Y')
        
        # Identificar ciclos
        ciclo_atual, ciclo_anterior = self._identificar_ciclos(data_de_ontem)
        
        # Formatar os ciclos como strings com dois dígitos
        self.ciclo_1 = f"{ciclo_atual['ciclo']:02d}" if ciclo_atual else None
        self.ciclo_2 = f"{ciclo_anterior['ciclo']:02d}" if ciclo_anterior else None
        
        logger.info(f"Ciclos identificados: atual={self.ciclo_1}, anterior={self.ciclo_2}")
    
    def _identificar_ciclos(self, data):
        """
        Identifica o ciclo atual e o anterior com base na data fornecida.
        
        Args:
            data (datetime): Data para identificação dos ciclos
            
        Returns:
            tuple: (ciclo_atual, ciclo_anterior)
        """
        ciclo_atual = None
        ciclo_anterior = None

        # Primeiro passo: encontrar o ciclo onde a data atual se encaixa
        for ciclo in ciclos_2025:
            inicio = datetime.strptime(ciclo["inicio"], "%d/%m/%Y")
            fim = datetime.strptime(ciclo["fim"], "%d/%m/%Y")
            
            if inicio <= data <= fim:
                ciclo_atual = ciclo
                break
        
        # Segundo passo: encontrar o ciclo anterior
        if ciclo_atual:
            # Se encontramos um ciclo atual, precisamos do imediatamente anterior
            indice_atual = ciclos_2025.index(ciclo_atual)
            if indice_atual > 0:  # Se não for o primeiro ciclo
                ciclo_anterior = ciclos_2025[indice_atual - 1]
        else:
            # Se não encontramos um ciclo atual (estamos entre ciclos ou após o último)
            for ciclo in reversed(ciclos_2025):
                fim = datetime.strptime(ciclo["fim"], "%d/%m/%Y")
                if data > fim:
                    ciclo_atual = ciclo
                    indice_atual = ciclos_2025.index(ciclo)
                    if indice_atual > 0:
                        ciclo_anterior = ciclos_2025[indice_atual - 1]
                    break
        
        return ciclo_atual, ciclo_anterior
    
    def diaOntem(self):
        """Retorna a data de ontem como objeto datetime."""
        return datetime.today() - timedelta(days=1)
    
    def _esperar_exportar(self, by, valor, timeout=60, tentativas=60):
        """
        Função auxiliar para esperar e clicar em elementos com retry."""
        
        for tentativa in range(tentativas):
            try:
                elemento = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", elemento)
                time.sleep(0.5)  # Pequena pausa para garantir visibilidade
                self.driver.execute_script("arguments[0].click();", elemento)
                return True
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    logger.error(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                if self._esperar_elemento(by=By.XPATH, valor=r'//*[@id="msgAlert"]', time=30, tentativas=5):
                    logger.info("Erro detectado ao buscar dados")
                    return False
                logger.info(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _esperar_e_clicar(self, by, valor, timeout=30, tentativas=3):
        """
        Função auxiliar para esperar e clicar em elementos com retry.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            timeout: Tempo máximo de espera em segundos
            tentativas: Número de tentativas
            
        Returns:
            bool: True se o clique foi bem-sucedido
        """
        for tentativa in range(tentativas):
            try:
                elemento = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", elemento)
                time.sleep(0.5)  # Pequena pausa para garantir visibilidade
                self.driver.execute_script("arguments[0].click();", elemento)
                return True
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    logger.error(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                logger.info(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _esperar_elemento(self, by, valor, timeout=30, tentativas=3):
        """
        Função auxiliar para esperar elementos com retry.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            timeout: Tempo máximo de espera em segundos
            tentativas: Número de tentativas
            
        Returns:
            WebElement: O elemento encontrado
        """
        for tentativa in range(tentativas):
            try:
                return self.wait.until(
                    EC.element_to_be_clickable((by, valor))
                )
            except Exception as e:
                if tentativa == tentativas - 1:  # última tentativa
                    logger.error(f"Erro ao esperar elemento {valor}: {e}")
                    raise
                logger.info(f"Tentativa {tentativa + 1} falhou, tentando novamente...")
                time.sleep(1)
    
    def _preencher_campo(self, by, valor, texto, limpar=True):
        """
        Preenche um campo de texto com o valor especificado.
        
        Args:
            by: Tipo de localização (By.ID, By.XPATH, etc.)
            valor: Valor do localizador
            texto: Texto a ser inserido
            limpar: Se True, limpa o campo antes de preencher
        """
        elemento = self._esperar_elemento(by, valor)
        if limpar:
            elemento.clear()
        elemento.send_keys(texto)
    
    def entrar(self):
        """
        Realiza o login no sistema.
        
        Returns:
            bool: True se o login foi bem-sucedido
        """
        try:
            usuario = os.getenv('vdUsername')
            senha = os.getenv('vdPassword')
            
            if not usuario or not senha:
                raise ValueError("Credenciais não encontradas nas variáveis de ambiente")
            
            logger.info("Acessando página de login...")
            self.driver.get("https://sgi.e-boticario.com.br/Paginas/Acesso/Entrar.aspx?ReturnUrl=%2f")
            
            # Preenchendo credenciais
            self._preencher_campo(By.ID, "username", usuario)
            self._preencher_campo(By.ID, "password", senha)
            
            # Clicando no botão de login
            self._esperar_e_clicar(By.ID, "btnLogin")
            
            # Aguardando login completar
            self._esperar_elemento(By.ID, "menu-cod-1")
            
            logger.info("Login realizado com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"Erro ao fazer login: {str(e)}")
            if isinstance(e, ValueError):
                logger.error("Verifique se as variáveis de ambiente vdUsername e vdPassword estão configuradas")
            return False
    
    def tratarErroPainel(self, timeout=10):
        """
        Verifica e trata erros de painéis que podem aparecer.
        
        Args:
            timeout: Tempo máximo de espera em segundos
        
        Returns:
            bool: True se não houver erro ou se o erro foi tratado com sucesso
        """
        try:
            # Tenta localizar o botão OK em painéis de erro
            mensagem_painel = WebDriverWait(self.driver, timeout).until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="popupOkButton"]'))
            )
            
            if mensagem_painel.is_displayed():
                logger.info("Painel de erro detectado. Tentando resolver...")
                mensagem_painel.click()
                logger.info("Painel de erro fechado.")
                return False  # Indica que um erro foi detectado e tratado
            
        except TimeoutException:
            # Painel não apareceu, o que é bom
            return True
        except Exception as e:
            logger.error(f"Erro ao tratar painel: {e}")
            return False
    
    def pegarVendas(self):
        """
        Navega pelo sistema para extrair dados de vendas.
        
        Returns:
            bool: True se a operação foi bem-sucedida
        """
        try:
            # Navegar para o menu de vendas
            self._esperar_e_clicar(By.XPATH, '//*[@id="menu-cod-1"]/a')
            time.sleep(1)
            self._esperar_e_clicar(By.XPATH, '//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/a')
            time.sleep(1)
            self._esperar_e_clicar(By.XPATH, '//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/ul/li[4]/a')
            time.sleep(1)
            
            # Preencher os filtros de relatório
            # self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]')
            # time.sleep(6)
            # self._preencher_campo(By.XPATH, r'//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]', "na")
            # self._preencher_campo(By.XPATH, r'//*[@id="ContentPlaceHolder1_seletorBuscaDropDown_d1"]', "por")
            
            
            element = self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_situacaoDropDown_d1"]').send_keys("na")
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_seletorBuscaDropDown_d1"]').send_keys("por")
            
            # Preencher datas
            # time.sleep(2)
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_dataInicioTextBox_T2"]', self.data_formatada)
            # time.sleep(2)
            # self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_dataTerminoTextBox_T2"]')))
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_dataTerminoTextBox_T2"]', self.data_formatada)
            
            # Preencher ciclos
            # self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]')))
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]', self.ciclo_2)
            # time.sleep(2)
            
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_campanhaInicioDropDown_d1"]').send_keys(self.ciclo_2)
            time.sleep(3)
            
            # self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]')))
            # self._preencher_campo(By.XPATH, '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]', self.ciclo_1)
            # time.sleep(2)
            
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_campanhaTerminoDropDown_d1"]').send_keys(self.ciclo_1)
            time.sleep(5)
            # Preencher tipo de item
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_tipoItemPedidoDropDown_d1"]')))
            self.driver.find_element('xpath', '//*[@id="ContentPlaceHolder1_tipoItemPedidoDropDown_d1"]').send_keys("ve")
            
            # Configurar tipo de busca
            tipo_busca = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="ContentPlaceHolder1_tipoBuscaItemDropDown_d1"]'))
            )
            tipo_busca.send_keys(Keys.RIGHT)
            tipo_busca.send_keys(Keys.RIGHT)
            time.sleep(0.5)
            
            # Configurar tipo de relatório
            self.wait.until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_tipoRelatProdutoDropDown_d1"]')))
            self.driver.find_element(By.XPATH, '//*[@id="ContentPlaceHolder1_tipoRelatProdutoDropDown_d1"]').send_keys("an")
            
            # Clicar em buscar
            self._esperar_e_clicar(By.XPATH, '//*[@id="ContentPlaceHolder1_buscarButton_btn"]')
            
            # Verificar se houve erro
            if not self.tratarErroPainel():
                return False
            
            # Aguardar carregamento dos resultados
            time.sleep(10)
            
            # Clicar no botão de exportar
            if not (self._esperar_exportar(By.XPATH, '//*[@id="ContentPlaceHolder1_exportarButton2_btn"]')):
               return False
            
            self._esperar_e_clicar(By.XPATH, '//*[@id="tab-01"]/div[3]/div/div[2]/div/div[1]/span/label')
            
            # Capturar informações de resultados se necessário
            try:
                elemento_info = self.driver.find_element(By.XPATH, '//*[@id="ContentPlaceHolder1_pnlTextoResultado"]/span/b')
                texto_info = elemento_info.text
                logger.info(f"Informações dos resultados: {texto_info}")
            except:
                pass
            
            # Configurar a exportação
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_exportarPanel"]/div/div/div[2]/div[1]/div/div/div[2]/ul/li[2]/a')
            time.sleep(2)
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_colunasTab"]/div[1]/div/div/label')
            time.sleep(2)
            self._esperar_e_clicar(By.XPATH, '//*[@id="agendamentoExportacao_okButton_B1"]')
            
            # Aguardar botão OK do popup e fechar janela
            self._esperar_e_clicar(By.XPATH, '//*[@id="popupOkButton"]')
            time.sleep(3)
            
            # Realizar download do arquivo
            self.pegar_downloads()
            
            # Esperar download concluído
            self.esperar_download_concluido()
            
            # Fechar janelas extras
            self.fecharJanela()
            
            return True
        except Exception as e:
            logger.error(f"Erro na função vendas: {e}")
            return False
    
    def fecharJanela(self):
        """Fecha qualquer janela extra aberta pelo sistema."""
        try:
            # Verificar se existem múltiplas janelas abertas
            janelas = self.driver.window_handles
            if len(janelas) > 1:
                # Muda para a segunda janela e a fecha
                self.driver.switch_to.window(janelas[1])
                self.driver.close()
                # Volta para a janela principal
                self.driver.switch_to.window(janelas[0])
                logger.info("Janela extra fechada com sucesso")
        except Exception as e:
            logger.error(f"Erro ao fechar janela: {e}")
    
    def esperar_download_concluido(self, diretorio="downloads", timeout=300):
        """
        Espera até que um arquivo seja baixado completamente.
        
        Args:
            diretorio: Caminho para o diretório de download
            timeout: Tempo máximo de espera em segundos
        
        Returns:
            str: Caminho do arquivo baixado ou None se falhar
        """
        # Garantir que o diretório existe
        os.makedirs(diretorio, exist_ok=True)
        
        inicio = time.time()
        ultimo_tamanho = {}
        arquivo_baixado = None
        
        logger.info("Aguardando conclusão do download...")
        
        while time.time() - inicio < timeout:
            # Busca por arquivos parcialmente baixados
            arquivos_parciais = glob.glob(os.path.join(diretorio, "*.crdownload")) + \
                               glob.glob(os.path.join(diretorio, "*.part")) + \
                               glob.glob(os.path.join(diretorio, "*.download"))
            
            # Se não há arquivos parciais, verifica por novos arquivos completos
            if not arquivos_parciais:
                arquivos = glob.glob(os.path.join(diretorio, "*"))
                if arquivos:
                    # Pega o arquivo mais recente (assumindo que é o download atual)
                    arquivo_recente = max(arquivos, key=os.path.getctime)
                    
                    # Se o arquivo não mudou de tamanho nos últimos 3 segundos
                    # assume que o download está completo
                    tamanho_atual = os.path.getsize(arquivo_recente)
                    if arquivo_recente in ultimo_tamanho:
                        if tamanho_atual == ultimo_tamanho[arquivo_recente]:
                            arquivo_baixado = arquivo_recente
                            logger.info(f"Download concluído: {os.path.basename(arquivo_baixado)}")
                            return arquivo_baixado
                    
                    ultimo_tamanho[arquivo_recente] = tamanho_atual
            
            # Aguarda 1 segundo antes de verificar novamente
            time.sleep(1)
        
        logger.error(f"Tempo limite excedido ({timeout}s). Download não concluído.")
        return None
            
    
    def pegar_downloads(self):
        wait = WebDriverWait(self.driver, 120)
    
        try:
            # Clique em vários elementos conforme necessário
            elements = [
                '//*[@id="menu-cod-8"]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/ul/li[3]/a'
            ]
            
            for xpath in elements:
                element = self.wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
                self.driver.execute_script("arguments[0].click();", element)
                time.sleep(2)  # Adicione um tempo de espera se necessário
            
            # Código específico para clicar no botão de download com tratamento de exceção
            while True:
                try:
                    download_button = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_exportacoesGrid_baixarButton_0_btn_0"]')))
                    time.sleep(10)
                    self.driver.execute_script("arguments[0].click();", download_button)
                    time.sleep(10)
                    break  # Sai do loop se conseguir clicar no botão de download
                except TimeoutException:
                    # Verifica se o botão de alerta está presente
                    try:
                        alert_button = self.driver.find_element('xpath', '//*[@id="msgAlert"]')
                        if alert_button.is_displayed():
                            print("Alerta detectado. Recarregando a página...")
                            self.driver.refresh()  # Recarrega a página
                            time.sleep(5)  # Aguarda um tempo para a página recarregar
                            continue  # Volta para o início do loop
                    except NoSuchElementException:
                        pass  # Se o alerta não for encontrado, continua com a próxima tentativa
                except StaleElementReferenceException:
                    # Tenta buscar o elemento novamente se ocorrer StaleElementReferenceException
                    print("Elemento desatualizado detectado. Tentando buscar novamente...")
                    continue

                # Tentar clicar no botão de atualizar se o botão de download não estiver disponível
                try:
                    atualizar = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_atualizarButton_btn"]')))
                    self.driver.execute_script("arguments[0].click();", atualizar)
                    time.sleep(5)  # Adiciona um pequeno tempo de espera para o botão ser clicado
                except TimeoutException:
                    pass
        except StaleElementReferenceException:
            print("Elemento foi atualizado ou não está mais na página. Recarregando...")
            self.driver.refresh()  # Recarrega a página
            time.sleep(5)
            self.pegar_downloads()  # Tenta novamente
    
    def executar_fluxo_completo(self):
        """
        Executa o fluxo completo de extração de dados.
        
        Returns:
            bool: True se todo o fluxo foi bem-sucedido
        """
        try:
            # Criar diretório de downloads se não existir
            os.makedirs("downloads", exist_ok=True)
            
            # Realizar login
            if not self.entrar():
                logger.error("Falha no login. Abortando operação.")
                return False
            
            # Buscar e baixar dados de vendas
            if not self.pegarVendas():
                logger.error("Falha ao obter dados de vendas. Abortando operação.")
                return False
            
            logger.info("Fluxo completo executado com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"Erro no fluxo completo: {e}")
            return False
        finally:
            # Não fechar o navegador aqui, deixar isso para ser chamado explicitamente
            pass
    
    def fechar(self):
        """Fecha o navegador e limpa recursos."""
        try:
            if self.driver:
                self.driver.quit()
                self.driver = None
                logger.info("Navegador fechado com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao fechar o navegador: {e}")        

if __name__ == "__main__":
    # logger.info("Iniciando execução principal do script VendasCortes.py")
    # rpa = PegarGoogle()
    # while rpa.entrar():
    #     logger.info("Chamando método pegarVendas()")
    #     rpa.pegarVendas()
    logger.info("Execução principal finalizada")
    banco = Banco() 
    tratar = TratarDados()
    df = tratar.processar_arquivo_vendas()
    banco.inserirItensPedido(df)
    banco.fechar() 