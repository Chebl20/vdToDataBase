# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException,NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service 
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime, timedelta
import pandas as pd
import glob
import os
import numpy as np
from urllib.parse import quote
from sqlalchemy import create_engine, text
from sqlalchemy.types import String
from sqlalchemy.types import Integer
from sqlalchemy.types import Float
from sqlalchemy.types import DateTime
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException
import chromedriver_autoinstaller
from dotenv import load_dotenv
import logging
import io
import csv
from pandas.api.types import is_scalar
import psycopg2.extras
from seleniumbase import Driver

# Configuração do sistema de logging

def setup_logger():
    # Cria pasta de logs se não existir
    log_dir = "logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Define formato da data para o nome do arquivo de log
    data_hora_atual = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = f"{log_dir}/execucao_{data_hora_atual}.log"
    
    # Configuração do logger
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger()

# Inicialização do logger global
logger = setup_logger()

# Carregando variáveis de ambiente do arquivo .env
dotenv_path = r"C:\Users\Administrator\Desktop\vdToDataBase\.env" 
# Carregando variáveis de ambiente do arquivo .env
load_dotenv(dotenv_path=dotenv_path)

ciclos_2024 = [
    {"ciclo":  1, "inicio": "26/12/2023", "fim": "21/01/2024"},
    {"ciclo":  2, "inicio": "22/01/2024", "fim": "11/02/2024"},
    {"ciclo":  3, "inicio": "12/02/2024", "fim": "03/03/2024"},
    {"ciclo":  4, "inicio": "04/03/2024", "fim": "24/03/2024"},
    {"ciclo":  5, "inicio": "25/03/2024", "fim": "14/04/2024"},
    {"ciclo":  6, "inicio": "15/04/2024", "fim": "12/05/2024"},
    {"ciclo":  7, "inicio": "13/05/2024", "fim": "26/05/2024"},
    {"ciclo":  8, "inicio": "27/05/2024", "fim": "12/06/2024"},
    {"ciclo":  9, "inicio": "13/06/2024", "fim": "30/06/2024"},
    {"ciclo": 10, "inicio": "01/07/2024", "fim": "22/07/2024"},
    {"ciclo": 11, "inicio": "23/07/2024", "fim": "11/08/2024"},
    {"ciclo": 12, "inicio": "12/08/2024", "fim": "01/09/2024"},
    {"ciclo": 13, "inicio": "02/09/2024", "fim": "21/09/2024"},
    {"ciclo": 14, "inicio": "22/09/2024", "fim": "13/10/2024"},
    {"ciclo": 15, "inicio": "14/10/2024", "fim": "03/11/2024"},
    {"ciclo": 16, "inicio": "04/11/2024", "fim": "01/12/2024"},
    {"ciclo": 17, "inicio": "02/12/2024", "fim": "25/12/2024"}, 
]

class TratarDados():
    def __init__(self):
        # Caminhos portáveis: primeiro busca na pasta 'downloads' do projeto, depois em 'Downloads' do usuário
        base_dir = r"C:\Users\Administrator\Desktop"
        projeto_downloads = os.path.join(base_dir, 'download_path_databse')
        usuario_downloads = os.path.join(os.path.expanduser('~'), 'download_path_databse')

        padroes = [
            os.path.join(projeto_downloads, '*.csv'),
            os.path.join(usuario_downloads, '*.csv'),
        ]

        list_of_files = []
        for padrao in padroes:
            arquivos = glob.glob(padrao)
            if arquivos:
                list_of_files.extend(arquivos)

        if not list_of_files:
            raise FileNotFoundError("Nenhum arquivo CSV encontrado nas pastas padrão ('downloads' do projeto ou 'Downloads' do usuário).")

        self.file = max(list_of_files, key=os.path.getctime)
        
    def processar_arquivo_pedidos(self):

        try:
            print(self.file )
            logger.info(f"Iniciando processamento do arquivo: {self.file}")
            df = pd.read_csv(self.file,
                             sep='|',
                             encoding='utf-8',
                             on_bad_lines='skip',
                             engine='python',
                             dtype=str)

            logger.info(f"Arquivo lido com sucesso. Total de linhas: {len(df)}")

            # Mapeamento de colunas
            mapeamento_colunas = {
                'CodigoPedido': 'CodigoPedido',
                'Cód Externo Pedido': 'CodExternoPedido',
                'SituaçãoFiscal': 'SituacaoFiscal',
                'NotaFiscal': 'NotaFiscal',
                'Pessoa': 'Pessoa',
                'NomePessoa': 'NomePessoa',
                'Papel': 'Papel',
                'Ordem de Pedido': 'OrdemPedido',
                'QtdeItens': 'QtdeItens',
                'QtdeMateriais': 'QtdeMateriais',
                'ValorPedido': 'ValorPedido',
                'ValorTotalSemCCR': 'ValorTotalSemCCR',
                'ValorTabela': 'ValorTabela',
                'ValorPraticado': 'ValorPraticado',
                'ValorLiquido': 'ValorLiquido',
                'ValorProdutosRegulares': 'ValorProdutosRegulares',
                'ValorPraticadoProdutosRegulares': 'ValorPraticadoProdutosRegulares',
                'ValorTabelaProdutosRegulares': 'ValorTabelaProdutosRegulares',
                'MeioCaptacao': 'MeioCaptacao',
                'Tipo de Entrega': 'TipoEntrega',
                'SituaçãoComercial': 'SituacaoComercial',
                'DetalheSituaçãoComercial': 'DetalheSituacaoComercial',
                'SituacaoIntegracaoExterna': 'SituacaoIntegracaoExterna',
                'DetalheSituacaoIntExterna': 'DetalheSituacaoIntExterna',
                'Data Captação': 'DataCaptacao',
                'HoraPedido': 'HoraPedido',
                'Data Aprovação': 'DataAprovacao',
                'Data Marketing': 'DataMarketing',
                'PrevisãoEntrega': 'PrevisaoEntrega',
                'DataEntrega': 'DataEntrega',
                'DataAutorizaçãoFaturamento': 'DataAutorizacaoFaturamento',
                'Cód Linha de Separação': 'CodLinhaSeparacao',
                'DataFaturamento': 'DataFaturamento',
                'Ciclo Captação': 'CicloCaptacao',
                'SubCiclo': 'SubCiclo',
                'Ciclo Marketing': 'CicloMarketing',
                'CicloIndicador': 'CicloIndicador',
                'CicloCancelamento': 'CicloCancelamento',
                'CaptacaoRestrita': 'CaptacaoRestrita',
                'Dia do Ciclo': 'DiaCiclo',
                'PlanoPagamento': 'PlanoPagamento',
                'Logradouro': 'Logradouro',
                'Complemento': 'Complemento',
                'Bairro': 'Bairro',
                'Cidade': 'Cidade',
                'UF': 'UF',
                'CEP': 'CEP',
                'Referência': 'Referencia',
                'LogradouroEntrega': 'LogradouroEntrega',
                'ComplementoEntregaRetirada': 'ComplementoEntregaRetirada',
                'BairroEntregaRetirada': 'BairroEntregaRetirada',
                'CidadeEntregaRetirada': 'CidadeEntregaRetirada',
                'UFEntregaRetirada': 'UFEntregaRetirada',
                'CEPEntregaRetirada': 'CEPEntregaRetirada',
                'ReferênciaEntregaRetirada': 'ReferenciaEntregaRetirada',
                'Telefone': 'Telefone',
                'CódModeloComercial': 'CodModeloComercial',
                'ModeloComercial': 'ModeloComercial',
                'Cód Estrutura Pai': 'CodEstruturaPai',
                'EstruturaPai': 'EstruturaPai',
                'Cód Estrutura': 'CodEstrutura',
                'Estrutura': 'Estrutura',
                'Responsável Estrutura': 'ResponsavelEstrutura',
                'Telefone Responsável': 'TelefoneResponsavel',
                'Cód Usuário Criação': 'CodUsuarioCriacao',
                'Usuario de Criação': 'UsuarioCriacao',
                'Cód Usuário Finalização': 'CodUsuarioFinalizacao',
                'Usuario de Finalização': 'UsuarioFinalizacao',
                'Volume': 'Volume',
                'PesoEstimado': 'PesoEstimado',
                'PesoReal': 'PesoReal',
                'Lote de separação': 'LoteSeparacao',
                'CódCD': 'CodCD',
                'CanalDistribuicao': 'CanalDistribuicao',
                'Detalhe Entrega': 'DetalheMeioCaptacao'
            }

            # Renomear colunas existentes
            colunas_existentes = {k: v for k, v in mapeamento_colunas.items() if k in df.columns}
            logger.info(f"Colunas existentes após mapeamento: {list(colunas_existentes.values())}")
            df = df.rename(columns=colunas_existentes)

            logger.info(f"Colunas após renomear: {list(df.columns)}")

            if 'SituacaoComercial' not in df.columns:
                logger.warning("Coluna 'SituacaoComercial' NÃO encontrada após renomeação!")
            else:
                logger.info("Coluna 'SituacaoComercial' encontrada para processamento.")

            df['CodigoPedido'] = df['CodigoPedido'].astype(str)
            df['CodUsuarioCriacao'] = df['CodUsuarioCriacao'].astype(str)
            df['CodUsuarioFinalizacao'] = df['CodUsuarioFinalizacao'].astype(str)
            df['Pessoa'] = df['Pessoa'].astype(str)
            df['OrdemPedido'] = df['OrdemPedido'].astype(str)
            df['SituacaoComercial'] = df['SituacaoComercial'].astype(str)   

            # Filtrar apenas colunas válidas para inserção
            colunas_validas = [col for col in mapeamento_colunas.values() if col in df.columns]
            logger.info(f"Colunas válidas para inserção: {colunas_validas}")
            df = df[colunas_validas]

            # Conversão de tipos
            colunas_data = [
                'DataCaptacao', 'DataAprovacao', 'DataMarketing', 'PrevisaoEntrega',
                'DataEntrega', 'DataAutorizacaoFaturamento', 'DataFaturamento'
            ]
            def converter_data(valor):
                if pd.isna(valor) or valor == '':
                    return None
                
                formatos = ['%Y-%m-%d', '%d/%m/%Y', '%d-%m-%Y', '%Y/%m/%d']
                
                for formato in formatos:
                    try:
                        return pd.to_datetime(valor, format=formato).date()
                    except:
                        continue
                
                # Se nenhum formato funcionar, tenta conversão automática
                try:
                    return pd.to_datetime(valor).date()
                except:
                    return None

            # Aplicar a função
            for col in colunas_data:
                if col in df.columns:
                    logger.info(f"Processando coluna {col}")
                    df[col] = df[col].apply(converter_data)

            colunas_time = ['HoraPedido']
            for col in colunas_time:
                if col in df.columns:
                    df[col] = pd.to_datetime(df[col], errors='coerce').dt.time
                    
            colunas_float = [
                'ValorPedido', 'ValorTotalSemCCR', 'ValorTabela', 'ValorPraticado', 'ValorLiquido',
                'ValorProdutosRegulares', 'ValorPraticadoProdutosRegulares', 'ValorTabelaProdutosRegulares',
                'Volume', 'PesoEstimado', 'PesoReal'
            ]
            for col in colunas_float:
                if col in df.columns:
                    df[col] = df[col].str.replace('.', '', regex=False)   # remove separador de milhares, se houver
                    df[col] = df[col].str.replace(',', '.', regex=False)    
                    df[col] = pd.to_numeric(df[col], errors='coerce', downcast='float')

            colunas_int = ['QtdeItens', 'QtdeMateriais', 'DiaCiclo', 'Volume']
            for col in colunas_int:
                if col in df.columns:
                    # Substitua valores nulos por 0
                    df[col] = df[col].fillna(0)
                    # Primeiro, substitua strings inválidas por None
                    df[col] = df[col].apply(lambda x: None if (isinstance(x, str) and not x.isdigit()) else x)
                    # Converta para numérico, forçando erros inválidos para None
                    df[col] = pd.to_numeric(df[col], errors='coerce')
                    # Converta para inteiro, mantendo None para valores inválidos
                    df[col] = df[col].apply(lambda x: int(x) if pd.notna(x) and isinstance(x, (int, float)) else 0)
            
            # Substituir NaN, NaT, strings vazias e valores nulos por None para inserção no banco
            df = df.where(pd.notna(df), None)  # substitui NaN/NaT por None diretamente
            
            # Converter NaT para None explicitamente
            for col in df.columns:
                if pd.api.types.is_datetime64_any_dtype(df[col]):
                    df[col] = df[col].apply(lambda x: None if pd.isna(x) else x)

            # Truncar valores de texto que ultrapassam 100 caracteres
            for col in df.columns:
                if pd.api.types.is_string_dtype(df[col]):
                    df[col] = df[col].apply(lambda x: x[:100] if isinstance(x, str) else x)

            # Colunas que devem ser booleanas (ex: valores como "Sim"/"Não")
            colunas_booleanas = ['CaptacaoRestrita']  # adicione outras se houver

            for col in colunas_booleanas:
                if col in df.columns:
                    df[col] = df[col].map(lambda x: True if str(x).strip().lower() in ['sim', 'true', '1'] else False)

            logger.info("Processamento e conversão de dados concluídos com sucesso")
            return df

        except Exception as e:
            logger.error(f"Erro ao processar arquivo: {str(e)}")
            raise
 

class Banco():
    def __init__(self):
        self.engine = create_engine(os.getenv('DATABASE_URL')) 
        try:
            conn = self.engine.connect()
            result = conn.execute(text("SELECT 1"))
            if result.scalar() == 1:
                print("Conectado ao banco com sucesso!")
                self.criar_tabela()
            else:
                print("Erro ao conectar ao banco")
            conn.close()
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise
        
    def criar_tabela(self):
        try:
            with self.engine.connect() as conn:
                conn.execute(text("""
                    CREATE TABLE IF NOT EXISTS pedidos (
                        CodigoPedido varchar(30) primary key,
                        CodExternoPedido VARCHAR(50),
                        SituacaoFiscal VARCHAR(50),
                        NotaFiscal VARCHAR(50),
                        Pessoa varchar(20),
                        NomePessoa VARCHAR(255),
                        Papel VARCHAR(50),
                        OrdemPedido varchar(50),
                        QtdeItens INT,
                        QtdeMateriais INT,
                        ValorPedido DECIMAL(10, 2),
                        ValorTotalSemCCR DECIMAL(10, 2),
                        ValorTabela DECIMAL(10, 2),
                        ValorPraticado DECIMAL(10, 2),
                        ValorLiquido DECIMAL(10, 2),
                        ValorProdutosRegulares DECIMAL(10, 2),
                        ValorPraticadoProdutosRegulares DECIMAL(10, 2),
                        ValorTabelaProdutosRegulares DECIMAL(10, 2),
                        MeioCaptacao VARCHAR(100),
                        TipoEntrega VARCHAR(100),
                        SituacaoComercial VARCHAR(100),
                        DetalheSituacaoComercial VARCHAR(255),
                        SituacaoIntegracaoExterna VARCHAR(100),
                        DetalheSituacaoIntExterna VARCHAR(255),
                        DataCaptacao DATE,
                        HoraPedido TIME,
                        DataAprovacao DATE,
                        DataMarketing DATE,
                        PrevisaoEntrega DATE,
                        DataEntrega DATE,
                        DataAutorizacaoFaturamento DATE,
                        CodLinhaSeparacao VARCHAR(50),
                        DataFaturamento DATE,
                        CicloCaptacao VARCHAR(50),
                        SubCiclo VARCHAR(50),
                        CicloMarketing VARCHAR(50),
                        CicloIndicador VARCHAR(50),
                        CicloCancelamento VARCHAR(50),
                        CaptacaoRestrita BOOLEAN,
                        DiaCiclo INT,
                        PlanoPagamento VARCHAR(255),
                        Logradouro VARCHAR(255),
                        Complemento VARCHAR(255),
                        Bairro VARCHAR(100),
                        Cidade VARCHAR(100),
                        UF CHAR(2),
                        CEP VARCHAR(15),
                        Referencia VARCHAR(255),
                        LogradouroEntrega VARCHAR(255),
                        ComplementoEntregaRetirada VARCHAR(255),
                        BairroEntregaRetirada VARCHAR(100),
                        CidadeEntregaRetirada VARCHAR(100),
                        UFEntregaRetirada CHAR(2),
                        CEPEntregaRetirada VARCHAR(15),
                        ReferenciaEntregaRetirada VARCHAR(255),
                        Telefone VARCHAR(20),
                        CodModeloComercial VARCHAR(50),
                        ModeloComercial VARCHAR(255),
                        CodEstruturaPai VARCHAR(50),
                        EstruturaPai VARCHAR(255),
                        CodEstrutura VARCHAR(50),
                        Estrutura VARCHAR(255),
                        ResponsavelEstrutura VARCHAR(255),
                        TelefoneResponsavel VARCHAR(20),
                        CodUsuarioCriacao varchar(30),
                        UsuarioCriacao VARCHAR(255),
                        CodUsuarioFinalizacao varchar(30),
                        UsuarioFinalizacao VARCHAR(255),
                        Volume INT,
                        PesoEstimado DECIMAL(10, 2),
                        PesoReal DECIMAL(10, 2),
                        LoteSeparacao VARCHAR(50),
                        CodCD VARCHAR(50),
                        CanalDistribuicao VARCHAR(100),
                        DetalheMeioCaptacao VARCHAR(255)
                    )
                """))
                conn.commit()
                print("Tabela 'pedidos' criada/verificada com sucesso!")
        except Exception as e:
            print(f"Erro ao criar tabela: {e}")
            raise

    def inserirPedidos(self, pedidos):
        try:
            if hasattr(pedidos, 'to_dict'):
                pedidos = pedidos.to_dict('records')

            # Lista com as colunas exatas e na ordem correta
            colunas = [
                "CodigoPedido", "CodExternoPedido", "SituacaoFiscal", "NotaFiscal", "Pessoa", "NomePessoa", "Papel", "OrdemPedido",
                "QtdeItens", "QtdeMateriais", "ValorPedido", "ValorTotalSemCCR", "ValorTabela", "ValorPraticado", "ValorLiquido",
                "ValorProdutosRegulares", "ValorPraticadoProdutosRegulares", "ValorTabelaProdutosRegulares", "MeioCaptacao",
                "TipoEntrega", "SituacaoComercial", "DetalheSituacaoComercial", "SituacaoIntegracaoExterna",
                "DetalheSituacaoIntExterna", "DataCaptacao", "HoraPedido", "DataAprovacao", "DataMarketing", "PrevisaoEntrega",
                "DataEntrega", "DataAutorizacaoFaturamento", "CodLinhaSeparacao", "DataFaturamento", "CicloCaptacao", "SubCiclo",
                "CicloMarketing", "CicloIndicador", "CicloCancelamento", "CaptacaoRestrita", "DiaCiclo", "PlanoPagamento",
                "Logradouro", "Complemento", "Bairro", "Cidade", "UF", "CEP", "Referencia", "LogradouroEntrega",
                "ComplementoEntregaRetirada", "BairroEntregaRetirada", "CidadeEntregaRetirada", "UFEntregaRetirada",
                "CEPEntregaRetirada", "ReferenciaEntregaRetirada", "Telefone", "CodModeloComercial",
                "ModeloComercial", "CodEstruturaPai", "EstruturaPai", "CodEstrutura", "Estrutura",
                "ResponsavelEstrutura", "TelefoneResponsavel", "CodUsuarioCriacao", "UsuarioCriacao",
                "CodUsuarioFinalizacao", "UsuarioFinalizacao", "Volume", "PesoEstimado", "PesoReal",
                "LoteSeparacao", "CodCD", "CanalDistribuicao", "DetalheMeioCaptacao"
            ]

            # Filtrar e ordenar os dados conforme as colunas definidas
            values = [tuple(p.get(col, None) for col in colunas) for p in pedidos]

            insert_query = f"""
                INSERT INTO pedidos ({', '.join(colunas)})
                VALUES ({', '.join(['%s'] * len(colunas))})
                ON CONFLICT (CodigoPedido)
                DO UPDATE SET
                    {', '.join([f"{col} = EXCLUDED.{col}" for col in colunas if col != 'CodigoPedido'])}
                """

            conn = self.engine.raw_connection()
            cursor = conn.cursor()
            try:
                psycopg2.extras.execute_batch(cursor, insert_query, values)
                conn.commit()
                logger.info("Inserção/atualização de pedidos concluída com sucesso")
            except Exception as e:
                conn.rollback()
                logger.error(f"Erro ao inserir/atualizar pedidos: {str(e)}")
                raise
        except Exception as e:
            logger.error(f"Erro ao inserir/atualizar pedidos: {str(e)}")
            raise
        
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.engine:
                self.engine.dispose()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
    
    def consulta(self):
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT DISTINCT ciclocaptacao FROM pedidos"))
                return result
        except Exception as e:
            print(f"Erro ao conectar ao banco: {e}")
            raise


class PegarGoogle():
    
    def __init__(self):
        logger.info("Inicializando PegarGoogle e o driver do Chrome...")
        self.driver = None
        self.wait = None
        self.data_formatada = None
        self.ciclo_1 = None
        self.ciclo_2 = None
        
        # Diretório de download personalizado (portátil)
        base_dir = r"C:\Users\Administrator\Desktop"
        download_dir = os.path.join(base_dir, r'download_path_databse')
        self.download_dir = download_dir
        
        # Garantir que o diretório de download existe
        os.makedirs(download_dir, exist_ok=True)

        try:
            logger.info("Configurando opções do Chrome")

            logger.info("Iniciando Chrome")
            
            driver = Driver(
                browser="chrome",
                uc=True,  # Usa undetected-chromedriver para evitar bloqueios de bot
                incognito=False,  # Ou use guest_mode=True se não quiser salvar nada
                locale_code="pt-BR",
                guest_mode=True,   
                disable_gpu=True, # Cria perfil novo, sem conta
                headless=True,
                chromium_arg="--no-first-run,"
                    "--no-default-browser-check,"
                    "--disable-infobars,"
                    "--disable-popup-blocking,"
                    "--disable-extensions,"
                    "--disable-features=ChromeWhatsNewUI,"
                    "--disable-sync,"
                    "--disable-signin-promo,"
                    "--disable-background-networking,"
                    "--disable-features=SignInProfileCreation,ChromeSignin,"
            )
    
            driver.execute_cdp_cmd('Page.setDownloadBehavior', {
                'behavior': 'allow',
                'downloadPath': self.download_dir
            })

            self.driver = driver
            
            # Configurar comportamento de download via CDP
            self.driver.execute_cdp_cmd("Page.setDownloadBehavior", {
                "behavior": "allow",
                "downloadPath": download_dir
            })

            # Configurar wait com timeout mais longo (120s)
            logger.info("Configurando WebDriverWait com timeout de 120 segundos")
            self.wait = WebDriverWait(self.driver, 120)
            self.vars = {}
            
            # Maximizar a janela
            self.driver.maximize_window()
            logger.info("Setup do Selenium concluído")
            
            # Inicializar variáveis de ciclo
            self.ciclo = None

        except Exception as e:
            logger.error(f"Erro ao inicializar o Chrome: {e}")
            if isinstance(e, WebDriverException):
                logger.error("Erro específico do WebDriver. Verifique se o Chrome está instalado corretamente.")
            self.fechar()
            raise
            
    def _esperar_e_clicar(self, by, valor, timeout=30):
        """Função auxiliar para esperar e clicar em elementos com retry"""
        logger.info(f"Tentando clicar no elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de clicar no elemento: {valor}")
                elemento = self.wait.until(
                    EC.element_to_be_clickable((by, valor))
                )
                self.driver.execute_script("arguments[0].click();", elemento)
                logger.info(f"Clique bem-sucedido no elemento: {valor}")
                return True
            except Exception as e:
                if tentativa == 2:  # última tentativa 
                    logger.error(f"Erro ao clicar no elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def _esperar_elemento(self, by, valor, timeout=30):
        """Função auxiliar para esperar elementos com retry"""
        logger.info(f"Aguardando presença do elemento: {valor}")
        for tentativa in range(3):
            try:
                logger.debug(f"Tentativa {tentativa + 1} de localizar o elemento: {valor}")
                elemento = self.wait.until(
                    EC.presence_of_element_located((by, valor))
                )
                logger.info(f"Elemento localizado com sucesso: {valor}")
                return elemento
            except Exception as e:
                if tentativa == 2:  # última tentativa
                    logger.error(f"Erro ao esperar elemento {valor}: {e}")
                    raise
                logger.warning(f"Tentativa {tentativa + 1} falhou, tentando novamente em 1 segundo... Erro: {str(e)[:100]}")
                time.sleep(1)
                
    def entrar(self):
        try:
            self.driver.get("https://sgi.e-boticario.com.br/Paginas/Acesso/Entrar.aspx?ReturnUrl=%2f")
                
            usuario = 'chebljose@gmail.com'
            senha = 'Oliveira26@2004'
            self.driver.click(r'#btnLoginExterno')
            print("entrou no site")
            
            time.sleep(3)
            self.driver.click(r'#GoogleExchange')
            print("entrou no google")
            
            self.driver.type("#identifierId", usuario)
            self.driver.click("#identifierNext > div > button")
            print("Passando o usuario")

            self.driver.type("#password > div.aCsJod.oJeWuf > div > div.Xb9hP > input", senha)
            self.driver.click("#passwordNext > div > button")
            print("Passando a senha")
            time.sleep(10)
            return True
            
        except ValueError as e:
            logger.error(f"Erro de validação ao fazer login: {str(e)}")
            logger.error("Verifique se as variáveis de ambiente vdUsername e vdPassword estão configuradas")
            return False
        except Exception as e:
            logger.error(f"Erro ao fazer login: {str(e)}", exc_info=True)
            return False
            
    def pegarPedidos(self):
        try:
            logger.info("Iniciando processo de busca e exportação de pedidos")
            ciclo = 1
            
            # Navegação inicial
            logger.info("Navegando para o menu de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="menu-cod-1"]/a')
            logger.info("Expandindo submenu")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/a')
            logger.info("Acessando consulta de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="submenu-cod-1"]/div/div[1]/ul/li[1]/ul/li[2]/a')
            
            # Configurar filtros
            logger.info("Configurando filtros de busca")
            logger.info("Focando no campo de código externo")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_txtCodigoExternoPedido_Tb1"]')
            
            logger.info("Limpando campo de data inicial")
            data_inicio = self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_txtDataInicio_Tb1"]')
            data_inicio.clear()
            
            logger.info("Abrindo seletor de situações comerciais")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_cmsSituacaoComercial_Tb1"]')
            
            # Marcar opções de tipos de produto
            logger.info("Marcando todas as situações comerciais")
            situacoes_comerciais = [1,2,3,4,5,6,7,8]
            for situacao in situacoes_comerciais:
                xpath = f'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_cmsSituacaoComercial_D0"]/div/ul/li[{situacao}]/a/label'
                self._esperar_e_clicar(By.XPATH, xpath)
            
            # Configurando período de busca
            hoje = datetime.today()
            inicio = hoje - timedelta(days=1)
            inicio_formatado = inicio.strftime('%d%m%Y')
            fim_formatado = hoje.strftime('%d%m%Y')
            
            logger.info(f"Configurando período de busca: {inicio.strftime('%d/%m/%Y')} a {hoje.strftime('%d/%m/%Y')}")
            
            logger.info("Preenchendo data inicial")
            self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_txtDataInicio_Tb1"]').send_keys(inicio_formatado)
            
            logger.info("Preenchendo data final")
            self._esperar_elemento(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_txtDataFim_Tb1"]').send_keys(fim_formatado)
            
            logger.info("Aguardando 3 segundos para garantir que os filtros foram aplicados")
            time.sleep(3)

            # Buscar e exportar
            logger.info("Iniciando busca de pedidos")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_btnBuscar_B1"]')
            
            logger.info("Clicando no botão de exportar")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="ContentPlaceHolder1_ControleBuscaPedido_btnExportar_B1"]')
            
            logger.info("Selecionando opção de exportação")
            self._esperar_e_clicar(By.XPATH, r'//*[@id="tab-01"]/div[3]/div/div[3]/div/div[1]/span/label')
            
            logger.info("Iniciando processo de download")
            self.pegar_downloads()
            
            logger.info("Fechando janelas secundárias")
            self.fecharJanela()
            
            logger.info("Processo de busca e exportação de pedidos concluído com sucesso")
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao pegar pedidos: {e}", exc_info=True)
            raise
            
    def fecharJanela(self):
        logger.info("Tentando fechar janela secundária")
        try:
            logger.debug("Verificando número de janelas abertas")
            if WebDriverWait(self.driver, 10).until(EC.number_of_windows_to_be(2)):
                janelas = self.driver.window_handles
                logger.info(f"Detectadas {len(janelas)} janelas. Alternando para a janela secundária")
                self.driver.switch_to.window(janelas[1])
                logger.info("Fechando janela secundária")
                self.driver.close()
                logger.info("Voltando para a janela principal")
                self.driver.switch_to.window(janelas[0])
                logger.info("Janela secundária fechada com sucesso")
        except TimeoutException:
            logger.warning("Não foi detectada uma segunda janela para fechar")
        except Exception as e:
            logger.error(f"Erro ao fechar janela: {e}", exc_info=True)
            
    def pegar_downloads(self):
        wait = WebDriverWait(self.driver, 120)
        
        try:
            # Clique em vários elementos conforme necessário
            elements = [
                '//*[@id="agendamentoExportacao_exportarPanel"]/div/div/div[2]/div[1]/div/div/div[2]/ul/li[2]/a',
                '//*[@id="agendamentoExportacao_colunasTab"]/div[1]/div/div/label',
                '//*[@id="agendamentoExportacao_divIncluirDadosPessoais"]/label',
                '//*[@id="popupOkButton"]',
                '//*[@id="agendamentoExportacao_okButton_B1"]',
                '//*[@id="popupOkButton"]',
                '//*[@id="menu-cod-8"]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/a',
                '//*[@id="submenu-cod-8"]/div/div[1]/ul/li[10]/ul/li[3]/a'
            ]
            
            
            for xpath in elements:
                element = wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
                self.driver.execute_script("arguments[0].click();", element)
                time.sleep(2)  # Adicione um tempo de espera se necessário
            
            # Código específico para clicar no botão de download com tratamento de exceção
            while True:
                try:
                    download_button = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_exportacoesGrid_baixarButton_0_btn_0"]')))
                    time.sleep(10)
                    self.driver.execute_script("arguments[0].click();", download_button)
                    time.sleep(10)
                    break  # Sai do loop se conseguir clicar no botão de download
                except TimeoutException:
                    # Verifica se o botão de alerta está presente
                    try:
                        alert_button = self.driver.find_element('xpath', '//*[@id="msgAlert"]')
                        if alert_button.is_displayed():
                            logger.info("Alerta detectado. Recarregando a página...")
                            self.driver.refresh()  # Recarrega a página
                            time.sleep(5)  # Aguarda um tempo para a página recarregar
                            continue  # Volta para o início do loop
                    except NoSuchElementException:
                        pass  # Se o alerta não for encontrado, continua com a próxima tentativa
                except StaleElementReferenceException:
                    # Tenta buscar o elemento novamente se ocorrer StaleElementReferenceException
                    logger.info("Elemento desatualizado detectado. Tentando buscar novamente...")
                    continue

                # Tentar clicar no botão de atualizar se o botão de download não estiver disponível
                try:
                    atualizar = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(('xpath', '//*[@id="ContentPlaceHolder1_atualizarButton_btn"]')))
                    self.driver.execute_script("arguments[0].click();", atualizar)
                    time.sleep(5)  # Adiciona um pequeno tempo de espera para o botão ser clicado
                except TimeoutException:
                    pass
        except StaleElementReferenceException:
            logger.info("Elemento foi atualizado ou não está mais na página. Recarregando...")
            self.driver.refresh()  # Recarrega a página
            time.sleep(5)
            self.pegar_downloads()  # Tenta novamente
            
    def fechar(self):
        """Método para fechar o navegador"""
        try:
            if self.driver:
                self.driver.quit()
        except Exception as e:
            print(f"Erro ao fechar o navegador: {e}")
            
if __name__ == "__main__":
    logger.info("Iniciando execução principal do script Pedidos.py")
    
    rpa = PegarGoogle()
    while rpa.entrar():
        logger.info("Chamando método pegarPedidos()")
        if rpa.pegarPedidos():
            break
    
    logger.info("Execução principal finalizada")
    banco = Banco()
    banco.criar_tabela()
    tratar = TratarDados()
    df = tratar.processar_arquivo_pedidos()
    banco.inserirPedidos(df)
    banco.fechar()
    rpa.fechar()
    

# WITH vendas_filtradas AS (
#     SELECT *
#     FROM pedidos
#     WHERE 
#         ciclocaptacao = '11/2025'
#         AND situacaocomercial IN ('Aprovado', 'Entregue', 'Transporte', 'Reservado', 'Separação')
# ),

# vendas_ord AS (
#     SELECT
#         *,
#         CASE 
#             WHEN LAG("modelocomercial") OVER (PARTITION BY "pessoa" ORDER BY "datacaptacao") IS DISTINCT FROM "modelocomercial" 
#             THEN 1
#             ELSE 0
#         END AS inicio_grupo
#     FROM vendas_filtradsas
# ),

# grupos AS (
#     SELECT
#         *,
#         SUM(inicio_grupo) OVER (PARTITION BY "pessoa" ORDER BY "datacaptacao" ROWS UNBOUNDED PRECEDING) AS grupo_id
#     FROM vendas_ord
# ),

# grupos_agregados AS (
#     SELECT
#         "pessoa",
#         "usuariofinalizacao",
#         "nomepessoa",
#         "modelocomercial",
#         "valorpraticado",
#         "codigopedido",
#         "datacaptacao",
#         grupo_id,
#         FIRST_VALUE("modelocomercial") OVER (PARTITION BY "pessoa", grupo_id ORDER BY "datacaptacao") AS modelo_grupo
#     FROM grupos
# ),

# transicoes AS (
#     SELECT
#         g_anterior."pessoa",
#         g_anterior."usuariofinalizacao",
#         g_anterior."nomepessoa",
#         g_atual."codigopedido",
#         g_atual."valorpraticado"
#     FROM grupos_agregados g_atual
#     LEFT JOIN LATERAL (
#         SELECT *
#         FROM grupos_agregados g2
#         WHERE 
#             g2."pessoa" = g_atual."pessoa"
#             AND g2.grupo_id = g_atual.grupo_id - 1
#         ORDER BY g2."datacaptacao" DESC
#         LIMIT 1
#     ) g_anterior ON true
#     WHERE
#         g_anterior.modelo_grupo = 'Modelo - Centro Serviço'
#         AND g_atual.modelo_grupo = 'Modelo - App Revendedora'
# ),

# tabelaRev AS (
#     SELECT
#         "usuariofinalizacao" AS "nomepessoa",
#         SUM("valorpraticado") AS "ValorRepick",
#         COUNT(*) AS "Quantidade"
#     FROM transicoes
#     GROUP BY "usuariofinalizacao"
# )
# SELECT * FROM tabelaRev;
# query repick